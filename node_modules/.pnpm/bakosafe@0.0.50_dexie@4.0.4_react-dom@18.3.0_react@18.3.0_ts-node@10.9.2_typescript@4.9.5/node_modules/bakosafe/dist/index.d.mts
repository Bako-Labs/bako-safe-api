import { AxiosInstance } from 'axios';
import { FuelWalletLocked } from '@fuel-wallet/sdk';
import * as fuels from 'fuels';
import { BN, Resource, TransactionRequest, Operation, TransactionRequestLike, Provider, Predicate, ScriptTransactionRequest, TransactionStatus as TransactionStatus$1, TransactionResponse, BytesLike, FuelConnector, FuelConnectorEventTypes, Asset as Asset$1, JsonAbi } from 'fuels';

interface IAuthService {
}
interface IApiConfig {
    apiUrl: string;
    authToken?: string;
    account?: string;
}
declare enum TypeUser {
    FUEL = "FUEL",
    WEB_AUTHN = "WEB_AUTHN"
}
interface IBakoSafeAuth {
    address: string;
    token: string;
}
interface IBakoSafeAuthPayload {
    address: string;
    hash: string;
    createdAt: string;
    provider: string;
    encoder: string;
    user_id: string;
}

declare const accounts: {
    FULL: {
        account: string;
        address: string;
        privateKey: string;
    };
    STORE: {
        account: string;
        address: string;
        privateKey: string;
    };
    USER_1: {
        account: string;
        address: string;
        privateKey: string;
    };
    USER_2: {
        account: string;
        address: string;
        privateKey: string;
    };
    USER_3: {
        account: string;
        address: string;
        privateKey: string;
    };
    USER_4: {
        account: string;
        address: string;
        privateKey: string;
    };
    USER_5: {
        account: string;
        address: string;
        privateKey: string;
    };
};
type IAccountKeys = keyof typeof accounts;
type IDefaultAccount = {
    address: string;
    account?: string;
    privateKey?: string;
};

type IAsset = {
    name: string;
    slug: string;
    assetId: string;
};
type ITransferAsset = {
    assetId: string;
    amount: string;
    to: string;
};
type IAssetGroupById = {
    [name: string]: BN;
};
type IAssetGroupByTo = {
    [name: string]: {
        assetId: string;
        amount: BN;
        to: string;
    };
};

declare class Api {
    client: AxiosInstance;
    constructor(auth: IBakoSafeAuth);
}

declare class Asset {
    /**
     *  Asset: provides utils to organize assets
     */
    static assetsGroupById(list: ITransferAsset[]): Promise<IAssetGroupById>;
    static assetsGroupByTo(list: ITransferAsset[]): Promise<IAssetGroupByTo>;
    static addTransactionFee(_assets: IAssetGroupById, _fee: BN): Promise<{
        amount: BN;
        assetId: string;
    }[]>;
    static includeSpecificAmount(predicateCoins: Resource[], assets: ITransferAsset[]): ITransferAsset[];
}

declare const assetsList: IAsset[];

declare enum SortOption {
    ASC = "ASC",
    DESC = "DESC"
}
declare enum TransactionStatus {
    AWAIT_REQUIREMENTS = "await_requirements",
    PENDING_SENDER = "pending_sender",
    PROCESS_ON_CHAIN = "process_on_chain",
    SUCCESS = "success",
    DECLINED = "declined",
    FAILED = "failed"
}
interface ICreateTransactionPayload {
    predicateAddress: string;
    name?: string;
    hash: string;
    txData: TransactionRequest;
    status: TransactionStatus;
    assets: ITransferAsset[];
    sendTime?: Date;
    gasUsed?: string;
}
declare enum WitnessStatus {
    REJECTED = "REJECTED",
    DONE = "DONE",
    PENDING = "PENDING"
}
interface IWitnesses {
    id: string;
    signature: string;
    account: string;
    status: WitnessStatus;
    createdAt: string;
    updatedAt: string;
}
interface GetTransactionParams {
    predicateId?: string[];
    to?: string;
    hash?: string;
    status?: TransactionStatus[];
    perPage?: number;
    page?: number;
    orderBy?: string;
    sort?: SortOption;
}
declare enum TransactionProcessStatus {
    SUCCESS = "SuccessStatus",
    SQUIZED = "SqueezedOutStatus",
    SUBMITED = "SubmittedStatus",
    FAILED = "FailureStatus"
}
interface ITransactionResume {
    hash: string;
    totalSigners: number;
    requiredSigners: number;
    predicate: {
        id: string;
        address: string;
    };
    outputs: ITransferAsset[];
    status: TransactionStatus;
    witnesses?: string[];
    gasUsed?: string;
    sendTime?: Date;
}
interface ITransactionSummary {
    origin: string;
    name: string;
    image?: string;
    operations?: Operation[];
}
interface ITransaction extends ICreateTransactionPayload {
    id: string;
    name: string;
    createdAt: string;
    updatedAt: string;
    predicateId: string;
    witnesses: IWitnesses[];
    resume: ITransactionResume;
    assets: ITransferAsset[];
    summary?: ITransactionSummary;
}
interface ITransactionService {
    create: (payload: ICreateTransactionPayload) => Promise<ITransaction>;
    findByHash: (hash: string) => Promise<ITransaction>;
    findByTransactionID: (transactionId: string) => Promise<ITransaction>;
    sign: (BakoSafeTransactionId: string, account: string, signer: string, approve?: boolean) => Promise<ITransaction>;
    send: (BakoSafeTransactionId: string) => Promise<ITransactionResume>;
    verify: (BakoSafeTransactionId: string) => Promise<ITransactionResume>;
}

declare class TransactionService extends Api implements ITransactionService {
    constructor(auth: IBakoSafeAuth);
    create(payload: ICreateTransactionPayload): Promise<ITransaction>;
    findByHash(hash: string): Promise<ITransaction>;
    findByTransactionID(transactionId: string): Promise<ITransaction>;
    sign(BakoSafeTransactionId: string, account: string, signer: string, approve?: boolean): Promise<any>;
    send(BakoSafeTransactionId: string): Promise<any>;
    verify(BakoSafeTransactionId: string): Promise<any>;
}

interface IPagination<T> {
    currentPage: number;
    totalPages: number;
    nextPage: number;
    prevPage: number;
    perPage: number;
    total: number;
    data: T[];
}
interface PaginationParams {
    page: string;
    perPage: string;
}
declare const defaultListParams: {
    perPage: number;
    page: number;
    orderBy: string;
    sort: SortOption;
};

interface IPredicatePayload {
    name: string;
    description?: string;
    predicateAddress: string;
    minSigners: number;
    addresses: string[];
    bytes: string;
    abi: string;
    configurable: string;
    provider: string;
    chainId?: number;
}
interface IListTransactions extends GetTransactionParams, Omit<GetTransactionParams, 'predicateId'> {
}
interface IPredicate extends IPredicatePayload {
    id: string;
    members: {
        id: string;
        avatar: string;
        address: string;
        nickname: string;
    }[];
    owner: {
        id: string;
        address: string;
    };
    createdAt: string;
    updatedAt: string;
}
interface IPredicateService {
    create: (payload: IPredicatePayload) => Promise<IPredicate>;
    findByAddress: (predicateAddress: string) => Promise<IPredicate>;
    findById: (predicateAddress: string) => Promise<IPredicate>;
    hasReservedCoins: (predicateAddress: string) => Promise<string[]>;
    listPredicateTransactions: (params: GetTransactionParams) => Promise<IPagination<ITransaction>>;
}

declare class PredicateService extends Api implements IPredicateService {
    constructor(auth: IBakoSafeAuth);
    create(payload: IPredicatePayload): Promise<any>;
    findByAddress(predicateAddress: string): Promise<any>;
    findById(predicateId: string): Promise<any>;
    hasReservedCoins(predicateAddress: string): Promise<any>;
    listPredicateTransactions(params: GetTransactionParams): Promise<any>;
}

interface IConfVault {
    HASH_PREDICATE?: number[];
    SIGNATURES_COUNT: number;
    SIGNERS: string[];
    network: string;
    chainId: number;
}
declare enum ECreationtype {
    IS_OLD = "IS_OLD",
    IS_NEW = "IS_NEW"
}
interface ICreationOldVault {
    type: ECreationtype.IS_NEW;
    payload: IPayloadVault;
}
interface ICreationNewVault {
    type: ECreationtype.IS_OLD;
    payload: IPayloadVault;
}
type ICreation = ICreationOldVault | ICreationNewVault;
interface ITransferList {
    [id: string]: Transfer;
}
interface IInstanceNewTransfer {
    assets: ITransferAsset[];
    witnesses: string[];
}
type IBakoSafeIncludeTransaction = IFormatTransfer | TransactionRequestLike;
interface IPayloadVault {
    configurable: IConfVault;
    provider: Provider;
    name?: string;
    description?: string;
    transactionRecursiveTimeout?: number;
    abi?: string;
    bytecode?: string;
    BakoSafeAuth?: IBakoSafeAuth;
    BakoSafeVaultId?: string;
    BakoSafeVault?: IPredicate;
    api?: IPredicateService;
}
interface IBakoSafeApi extends IBakoSafeAuth {
    id?: string;
    predicateAddress?: string;
}
interface IBakoSafeGetTransactions {
    resume: ITransactionResume;
    witnesses: IWitnesses[];
}
interface IVault {
    getAbi: () => {
        [name: string]: unknown;
    };
    getBin: () => string;
    getConfigurable: () => IConfVault;
    BakoSafeGetTransactions: (params?: IListTransactions) => Promise<IPagination<IBakoSafeGetTransactions>>;
    BakoSafeIncludeTransaction: (params: IBakoSafeIncludeTransaction) => Promise<Transfer>;
}

/**
 * `Vault` are extension of predicates, to manager transactions, and sends.
 */
declare class Vault extends Predicate<[]> implements IVault {
    private bin;
    private abi;
    private api;
    private auth;
    private configurable;
    name: string;
    BakoSafeVault: IPredicate;
    BakoSafeVaultId: string;
    description?: string;
    transactionRecursiveTimeout: number;
    protected constructor({ configurable, provider, abi, bytecode, name, description, BakoSafeVaultId, BakoSafeVault, BakoSafeAuth, transactionRecursiveTimeout, api, }: IPayloadVault);
    /**
     * Creates an instance of the Predicate class.
     *
     * @param configurable - The parameters of signature requirements.
     *      @param HASH_PREDICATE - Hash to works an unic predicate, is not required, but to instance old predicate is an number array
     *      @param SIGNATURES_COUNT - Number of signatures required of predicate
     *      @param SIGNERS - Array string of predicate signers
     * @param abi - The JSON abi to BakoSafe multisig.
     * @param bytecode - The binary code of preficate BakoSafe multisig.
     * @param transactionRecursiveTimeout - The time to refetch transaction on BakoSafe API.
     * @param BakoSafeAuth - The auth to BakoSafe API.
     *
     * @returns an instance of Vault
     **/
    static create(params: IPayloadVault | IBakoSafeApi): Promise<Vault>;
    /**
     * To use BakoSafe API, auth is required
     *
     * @returns if auth is not defined, throw an error
     */
    private verifyAuth;
    /**
     * Send a caller to BakoSafe API to save predicate
     * Set BakoSafeVaultId and BakoSafeVault
     *
     *
     * @returns if auth is not defined, throw an error
     */
    private createOnService;
    /**
     * Make configurable of predicate
     *
     * @param {IConfVault} configurable - The parameters of signature requirements.
     * @returns an formatted object to instance a new predicate
     */
    private static makePredicate;
    /**
     * Include new transaction to vault
     *
     * @param {IFormatTransfer} param - IFormatTransaction or TransactionRequestLike
     * @param {TransactionRequestLike} param - IFormatTransaction or TransactionRequestLike
     * @returns return a new Transfer instance
     */
    BakoSafeIncludeTransaction(param: IBakoSafeIncludeTransaction): Promise<Transfer>;
    /**
     * Return an list of transaction of this vault
     *
     *
     * @param {IListTransactions} params - The params to list transactions
     *  - has optional params
     *  - by default, it returns the first 10 transactions
     *
     *
     * @returns {Promise<IPagination<IBakoSafeGetTransactions>>} an transaction paginated transaction list
     *
     *
     */
    BakoSafeGetTransactions(params?: IListTransactions): Promise<{
        data: {
            resume: ITransactionResume;
            witnesses: IWitnesses[];
        }[];
        currentPage: number;
        totalPages: number;
        nextPage: number;
        prevPage: number;
        perPage: number;
        total: number;
    }>;
    /**
     * Return an list of transaction of this vault
     * @param transactionId - The transaction id on BakoSafeApi
     *
     * @returns an transaction list
     *
     *
     */
    BakoSafeGetTransaction(transactionId: string): Promise<Transfer>;
    /**
     * Return abi of this vault
     *
     * @returns an abi
     */
    getAbi(): {
        [name: string]: unknown;
    };
    /**
     * Return binary of this vault
     *
     * @returns an binary
     */
    getBin(): string;
    /**
     * Return this vault configurables state
     *
     * @returns configurables [signers, signers requested, hash]
     */
    getConfigurable(): IConfVault;
}

declare const defaultValues: {
    [name: string]: string;
};
declare const makeHashPredicate: () => string;
declare const makeSubscribers: (subscribers: string[]) => string[];
declare const instanceByOldUtil: (params: IBakoSafeApi) => Promise<IPayloadVault>;
declare const instanceByNewUtil: (params: IPayloadVault) => IPayloadVault;
declare const isOldPredicate: (param: IBakoSafeApi | IPayloadVault) => Promise<{
    is: boolean;
    data: IPayloadVault | undefined;
}>;
declare const isNewPredicate: (param: IBakoSafeApi | IPayloadVault) => Promise<{
    is: boolean;
    data: IPayloadVault | undefined;
}>;
declare const validations: (configurable: IConfVault) => void;
declare const identifyCreateVaultParams: (param: IPayloadVault | IBakoSafeApi) => Promise<ICreation>;

interface TransferConstructor {
    name: string;
    service?: ITransactionService;
    witnesses: string[];
    transactionRequest: TransactionRequest;
    BakoSafeScript: ScriptTransactionRequest;
    BakoSafeTransaction?: ITransaction;
    BakoSafeTransactionId?: string;
    vault: Vault;
}
declare enum ECreationTransactiontype {
    IS_OLD = "IS_OLD",
    IS_NEW = "IS_NEW",
    IS_SCRIPT = "IS_SCRIPT"
}
interface ICreationOldTransfer {
    type: ECreationTransactiontype.IS_NEW;
    payload: TransferConstructor;
}
interface ICreationNewTransfer {
    type: ECreationTransactiontype.IS_OLD;
    payload: TransferConstructor;
}
interface ICreationScriptTransfer {
    type: ECreationTransactiontype.IS_SCRIPT;
    payload: TransferConstructor;
}
type ICreationTransaction = ICreationOldTransfer | ICreationNewTransfer | ICreationScriptTransfer;
type TransferFactoryParam = string | IFormatTransfer | TransactionRequestLike | ITransaction;
interface TransferFactory {
    auth?: IBakoSafeAuth;
    transfer: TransferFactoryParam;
    vault: Vault;
    isSave?: boolean;
}
interface IPayloadTransfer {
    assets: ITransferAsset[];
    witnesses?: string[];
    name?: string;
}
interface IFormatTransfer {
    name: string;
    assets: ITransferAsset[];
    witnesses?: string[];
}
interface IInstanceTransfer {
    txData: TransactionRequest;
    hash: string;
}
interface IRequiredWitnesses {
    required: number;
    signed: number;
    witnesses: IWitnesses[];
}
interface ITransferResult {
    status: TransactionStatus$1;
    block?: string;
    witnesses?: string[];
    outputs?: ITransferAsset[];
    BakoSafeID?: string;
    fee?: string;
    gasUsed?: string;
}
interface ISendTransaction {
    status: string;
    block: string;
    gasUsed: string;
}
declare enum TransferInstanceError {
    REQUIRED_AUTH = "Required credentials",
    INVALID_PARAMETER = "Invalid instance parameters"
}
interface ITransfer {
    send(): void;
    getScript(): TransactionRequest;
    wait(): Promise<ITransactionResume | undefined>;
    getAssets(): ITransferAsset[];
}

/**
 * `Transfer` are extension of ScriptTransactionRequest, to create and send transactions
 */
declare class Transfer {
    name: string;
    witnesses: string[];
    BakoSafeScript: ScriptTransactionRequest;
    BakoSafeTransaction: ITransaction;
    transactionRequest: TransactionRequest;
    BakoSafeTransactionId: string;
    private vault;
    private service?;
    protected constructor({ vault, name, transactionRequest, BakoSafeScript, service, BakoSafeTransaction, BakoSafeTransactionId, }: TransferConstructor);
    /**
     * Create a new transaction instance
     *
     * @param {TransferFactory} param - TransferFactory params
     *        @param {string | ITransfer | ITransaction} transfer - Transaction ID or ITransfer or ITransaction
     *        @param {IBakoSafeAuth} auth - BakoSafeAuth instance
     *        @param {Vault} vault - Vault instance
     *        @param {boolean} isSave - Save transaction on BakoSafeAPI
     * @returns return a new Transfer instance
     */
    static instance(param: TransferFactory): Promise<Transfer>;
    /**
     * Create the url to consult the fuel block explorer
     *
     * @returns link of transaction block
     */
    makeBlockUrl(block: string | undefined): string;
    /**
     * Generates and formats the transaction hash of transaction instance
     *
     * @returns Hash of this transaction
     */
    getHashTxId(): string;
    /**
     * Configure outputs and parameters of transaction instance.
     *
     * @returns this transaction configured and your hash
     */
    /**
     * Using BakoSafe auth or default send of predicate, send this transaction to chain
     *
     * @returns an resume for transaction
     */
    send(): Promise<ITransactionResume | TransactionResponse | {
        BakoSafeID: string;
        hash: string;
        totalSigners: number;
        requiredSigners: number;
        predicate: {
            id: string;
            address: string;
        };
        outputs: ITransferAsset[];
        status: TransactionStatus;
        witnesses?: string[] | undefined;
        gasUsed?: string | undefined;
        sendTime?: Date | undefined;
    }>;
    /**
     * Promise to return result of function
     *
     * todo: monitore send with an socket server
     * Connect to api socket using name: [TRANSACTION_WAIT]:${transactionId}
     * Await an message on event [TRANSACTION_WAIT]:${transactionId}
     * and resolves a promise returns a result (returned on content of message)
     *
     * @returns an resume for transaction
     */
    wait(): Promise<ITransactionResume>;
}

interface BakoSafeScriptTransactionConstructor {
    gasPrice: BN;
    gasLimit: BN;
    script: BytesLike;
}
declare class BakoSafeScriptTransaction extends ScriptTransactionRequest {
    constructor({ script, gasLimit, gasPrice }?: BakoSafeScriptTransactionConstructor);
    instanceTransaction(_coins: Resource[], vault: Predicate<[]>, outputs: IAssetGroupByTo, witnesses?: string[]): Promise<void>;
}

declare const transactionScript: Uint8Array;
declare function recoverSigner(signer: string, tx_id: string): string | undefined;
declare const getHashTxId: (script: TransactionRequestLike, chainId: number) => string;
declare const formatTransaction: ({ vault, assets, witnesses, }: IFormatTransfer & {
    vault: Vault;
}) => Promise<BakoSafeScriptTransaction>;
declare const isNewTransaction: ({ transfer, auth, vault, }: TransferFactory) => Promise<{
    is: boolean;
    data: {
        vault: Vault;
        service: TransactionService | undefined;
        BakoSafeTransaction: ITransaction | undefined;
        name: string;
        transactionRequest: fuels.TransactionRequest;
        BakoSafeScript: BakoSafeScriptTransaction;
        witnesses: never[];
        BakoSafeTransactionId: string | undefined;
    };
} | {
    is: false | "";
    data: undefined;
}>;
declare const isOldTransaction: ({ transfer, auth, vault, }: TransferFactory) => Promise<{
    is: true;
    data: TransferConstructor;
} | {
    is: false;
    data: undefined;
}>;
declare const isNewTransactionByScript: ({ transfer, auth, vault, isSave, }: TransferFactory) => Promise<{
    is: true;
    data: {
        vault: Vault;
        service: TransactionService | undefined;
        witnesses: string[];
        name: string;
        transactionRequest: fuels.TransactionRequest;
        BakoSafeScript: ScriptTransactionRequest;
        BakoSafeTransaction: ITransaction | undefined;
        BakoSafeTransactionId: string | undefined;
    };
} | {
    is: false | "";
    data: undefined;
}>;
declare const identifyCreateTransactionParams: (param: TransferFactory) => Promise<ICreationTransaction>;

declare class AuthService implements IAuthService {
    BakoSafeAuth?: IBakoSafeAuth;
    client: AxiosInstance;
    protected constructor({ address, token }: IBakoSafeAuth);
    static create(account: IAccountKeys, provider: string): Promise<AuthService>;
    static signerByPk(pk: string, code: string): Promise<string>;
    static signerByAccount(wallet: FuelWalletLocked, code: string): Promise<string>;
    signTransaction(wallet: FuelWalletLocked, BakoSafeAuthTransactionId: string, approve?: boolean): Promise<void>;
}

declare class AddressUtils {
    static hex2string(add: string[]): string[];
}

declare const defaultConfig: {
    PROVIDER: string;
    SERVER_URL: string;
    CLIENT_URL: string;
    ENCODER: string;
};
declare const gasConfig: {
    GAS_PRICE: number;
    GAS_LIMIT: number;
};
type DefaultConfigurables = typeof defaultConfig;
type DefaultConfigurablesKeys = keyof DefaultConfigurables;
type GasConfigurables = typeof gasConfig;
type GasConfigurablesKeys = keyof GasConfigurables;
declare const BakoSafe: {
    setup: (params: Partial<DefaultConfigurables>) => void;
    setChainConfig: (params: Partial<GasConfigurables>) => void;
    get: (key: DefaultConfigurablesKeys) => string;
    getChainConfig: (key: GasConfigurablesKeys) => number;
};

declare enum BakoSafeConnectors {
    ACCOUNTS = "accounts",
    CURRENT_ACCOUNT = "currentAccount",
    TRANSACTION_CREATED = "[TRANSACTION_CREATED]",
    TRANSACTION_SEND = "[TRANSACTION_SEND]",
    AUTH_CONFIRMED = "[AUTH_CONFIRMED]",
    AUTH_REJECTED = "[AUTH_REJECTED]",
    AUTH_DISCONECT_DAPP = "[AUTH_DISCONECT_DAPP]",
    AUTH_DISCONECT_CONFIRM = "[AUTH_DISCONECT_CONFIRM]",
    CONNECTION = "connection",
    POPUP_TRANSFER = "[POPUP_TRANSFER]_connected",
    CONNECTED_NETWORK = "[CONNECTED_NETWORK]",
    DEFAULT = "message"
}

type FuelABI = JsonAbi;
type Network = {
    url: string;
    chainId: number;
};
declare class BakoSafeConnector extends FuelConnector {
    name: string;
    metadata: {
        image: {
            light: string;
            dark: string;
        };
        install: {
            action: string;
            link: string;
            description: string;
        };
    };
    installed: boolean;
    connected: boolean;
    events: {
        ACCOUNTS: BakoSafeConnectors.ACCOUNTS;
        CURRENT_ACCOUNT: BakoSafeConnectors.CURRENT_ACCOUNT;
        TRANSACTION_CREATED: BakoSafeConnectors.TRANSACTION_CREATED;
        TRANSACTION_SEND: BakoSafeConnectors.TRANSACTION_SEND;
        AUTH_CONFIRMED: BakoSafeConnectors.AUTH_CONFIRMED;
        AUTH_REJECTED: BakoSafeConnectors.AUTH_REJECTED;
        AUTH_DISCONECT_DAPP: BakoSafeConnectors.AUTH_DISCONECT_DAPP;
        AUTH_DISCONECT_CONFIRM: BakoSafeConnectors.AUTH_DISCONECT_CONFIRM;
        CONNECTION: BakoSafeConnectors.CONNECTION;
        POPUP_TRANSFER: BakoSafeConnectors.POPUP_TRANSFER;
        CONNECTED_NETWORK: BakoSafeConnectors.CONNECTED_NETWORK;
        DEFAULT: BakoSafeConnectors.DEFAULT;
        connectors: FuelConnectorEventTypes.connectors;
        currentConnector: FuelConnectorEventTypes.currentConnector;
        connection: FuelConnectorEventTypes.connection;
        accounts: FuelConnectorEventTypes.accounts;
        currentAccount: FuelConnectorEventTypes.currentAccount;
        networks: FuelConnectorEventTypes.networks;
        currentNetwork: FuelConnectorEventTypes.currentNetwork;
        assets: FuelConnectorEventTypes.assets;
        abis: FuelConnectorEventTypes.abis;
    };
    private readonly socket;
    private readonly sessionId;
    private readonly api;
    private dAppWindow;
    constructor();
    connect(): Promise<boolean>;
    sendTransaction(_address: string, _transaction: TransactionRequestLike): Promise<string>;
    ping(): Promise<boolean>;
    version(): Promise<{
        app: string;
        network: string;
    }>;
    isConnected(): Promise<any>;
    accounts(): Promise<any>;
    currentAccount(): Promise<any>;
    disconnect(): Promise<boolean>;
    currentNetwork(): Promise<any>;
    assets(): Promise<Asset$1[]>;
    signMessage(address: string, message: string): Promise<string>;
    addAssets(assets: Asset$1[]): Promise<boolean>;
    addAsset(assets: Asset$1): Promise<boolean>;
    addNetwork(networkUrl: string): Promise<boolean>;
    selectNetwork(network: Network): Promise<boolean>;
    networks(): Promise<Array<Network>>;
    addABI(_contractId: string, _abi: JsonAbi): Promise<boolean>;
    getABI(id: string): Promise<FuelABI | null>;
    hasABI(id: string): Promise<boolean>;
}

export { AddressUtils, Asset, AuthService, BakoSafe, BakoSafeConnector, BakoSafeConnectors, BakoSafeScriptTransaction, type DefaultConfigurables, type DefaultConfigurablesKeys, ECreationTransactiontype, ECreationtype, type GasConfigurables, type GasConfigurablesKeys, type GetTransactionParams, type IApiConfig, type IAsset, type IAssetGroupById, type IAssetGroupByTo, type IAuthService, type IBakoSafeApi, type IBakoSafeAuth, type IBakoSafeAuthPayload, type IBakoSafeGetTransactions, type IBakoSafeIncludeTransaction, type IConfVault, type ICreateTransactionPayload, type ICreation, type ICreationNewTransfer, type ICreationNewVault, type ICreationOldTransfer, type ICreationOldVault, type ICreationScriptTransfer, type ICreationTransaction, type IDefaultAccount, type IFormatTransfer, type IInstanceNewTransfer, type IInstanceTransfer, type IListTransactions, type IPagination, type IPayloadTransfer, type IPayloadVault, type IPredicate, type IPredicatePayload, type IPredicateService, type IRequiredWitnesses, type ISendTransaction, type ITransaction, type ITransactionResume, type ITransactionService, type ITransactionSummary, type ITransfer, type ITransferAsset, type ITransferList, type ITransferResult, type IVault, type IWitnesses, type PaginationParams, PredicateService, SortOption, TransactionProcessStatus, TransactionService, TransactionStatus, Transfer, type TransferConstructor, type TransferFactory, type TransferFactoryParam, TransferInstanceError, TypeUser, Vault, WitnessStatus, accounts, assetsList, defaultConfig, defaultListParams, defaultValues, formatTransaction, gasConfig, getHashTxId, identifyCreateTransactionParams, identifyCreateVaultParams, instanceByNewUtil, instanceByOldUtil, isNewPredicate, isNewTransaction, isNewTransactionByScript, isOldPredicate, isOldTransaction, makeHashPredicate, makeSubscribers, recoverSigner, transactionScript, validations };

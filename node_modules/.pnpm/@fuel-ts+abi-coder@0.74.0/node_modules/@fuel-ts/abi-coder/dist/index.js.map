{"version":3,"sources":["../src/index.ts","../src/coders/abstract-coder.ts","../src/coders/v0/array.ts","../src/constants.ts","../src/utilities.ts","../src/coders/v0/u64.ts","../src/coders/v0/b256.ts","../src/coders/v0/b512.ts","../src/coders/v0/boolean.ts","../src/coders/v0/enum.ts","../src/coders/v0/number.ts","../src/coders/v0/string.ts","../src/coders/v0/struct.ts","../src/coders/v0/option.ts","../src/coders/v0/tuple.ts","../src/coders/v0/vec.ts","../src/interface.ts","../src/abi-coder.ts","../src/coders/v0/byte.ts","../src/coders/v0/raw-slice.ts","../src/coders/v0/stdString.ts","../src/coders/v1/boolean.ts","../src/coders/v1/byte.ts","../src/coders/v1/enum.ts","../src/coders/v1/number.ts","../src/coders/v1/raw-slice.ts","../src/coders/v1/std-string.ts","../src/coders/v1/string.ts","../src/coders/v1/struct.ts","../src/coders/v1/tuple.ts","../src/coders/v1/vec.ts","../src/resolved-abi-type.ts","../src/function-fragment.ts"],"sourcesContent":["export { Coder, InputValue, DecodedValue } from './coders/abstract-coder';\nexport { ArrayCoder } from './coders/v0/array';\nexport { B256Coder } from './coders/v0/b256';\nexport { B512Coder } from './coders/v0/b512';\nexport { BooleanCoder } from './coders/v0/boolean';\nexport { EnumCoder } from './coders/v0/enum';\nexport { NumberCoder } from './coders/v0/number';\nexport { StringCoder } from './coders/v0/string';\nexport { StructCoder } from './coders/v0/struct';\nexport { TupleCoder } from './coders/v0/tuple';\nexport { U64Coder } from './coders/v0/u64';\nexport { VecCoder } from './coders/v0/vec';\nexport type { FunctionFragment } from './function-fragment';\nexport { Interface } from './interface';\nexport { JsonAbi } from './json-abi';\nexport {\n  SCRIPT_FIXED_SIZE,\n  INPUT_COIN_FIXED_SIZE,\n  WORD_SIZE,\n  ASSET_ID_LEN,\n  CONTRACT_ID_LEN,\n  calculateVmTxMemory,\n} from './constants';\n","import type { BN } from '@fuel-ts/math';\nimport type { BytesLike } from 'ethers';\n\nimport type { Option } from './v0/option';\n\ntype Primitive = string | number | boolean;\n\n/**\n * These are configurable options to be used when encoding.\n *\n * Firstly we should consider the encoding version being used. For more info on this\n * please refer to the fuel specs (https://github.com/FuelLabs/fuel-specs);\n *\n * Version 0:\n *\n * This is the currently supported version. It offers the following configurable options\n * regarding the encoding of small bytes:\n *\n * These options relates only to:\n *  - NumberCoder (u8, u16, u32)\n *  - BooleanCoder\n *\n * 1) isSmallBytes (default=false)\n *\n * Describes how many bytes it will occupy:\n *\n * false — occupies 8 bytes (default), and should be used when underneath:\n *    • standalone\n *    • tuple\n *    • struct\n *    • enum\n *\n * true — occupies 1 byte, and should be used when underneath:\n *    • array\n *    • vector\n *\n *\n *\n * 2) isRightPadded (default=false)\n *\n * Used only when `isSmallBytes` is FALSE.\n *\n * Describes how the padding should happen:\n *\n *  false —— left padded (default), and should be used when underneath:\n *    • standalone\n *    • array\n *    • vector\n *    • enum\n *    • only one function argument\n *\n *  true —— right padded, and should be used when underneath:\n *    • struct\n *    • tuple\n *    • multiple function arguments\n *    • configurable\n *\n *\n * Version 1:\n *\n * It currently is supported only by logs, but has no specific configurable options.\n * More information on the improvements made in this version can be found in the\n * fuel specs (https://github.com/FuelLabs/fuel-specs/blob/master/src/abi/argument-encoding.md#version-1\n */\nexport type EncodingOptions = {\n  version?: number;\n  isSmallBytes?: boolean;\n  isRightPadded?: boolean;\n};\n\n/**\n * The type of value you can provide to `Coder.encode`\n */\nexport type InputValue<T = void> =\n  | Primitive\n  | BN\n  | Option<T>\n  | BytesLike\n  | InputValue[]\n  | { [key: string]: InputValue }\n  | Record<string, Primitive | BytesLike>;\n\n/**\n * The type of value you can get from `Coder.decode`\n */\nexport type DecodedValue =\n  | Primitive\n  | DecodedValue[]\n  | { [key: string]: DecodedValue }\n  | Record<string, Primitive>;\n\nexport type TypesOfCoder<TCoder> = TCoder extends Coder<infer TInput, infer TDecoded>\n  ? { Input: TInput; Decoded: TDecoded }\n  : never;\n\nexport abstract class Coder<TInput = unknown, TDecoded = unknown> {\n  readonly name: string;\n  readonly type: string;\n  readonly encodedLength: number;\n\n  constructor(name: string, type: string, encodedLength: number) {\n    this.name = name;\n    this.type = type;\n    this.encodedLength = encodedLength;\n  }\n\n  abstract encode(value: TInput, length?: number): Uint8Array;\n\n  abstract decode(data: Uint8Array, offset: number, length?: number): [TDecoded, number];\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport { MAX_BYTES } from '../../constants';\nimport { concatWithDynamicData } from '../../utilities';\nimport type { TypesOfCoder } from '../abstract-coder';\nimport { Coder } from '../abstract-coder';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport class ArrayCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n  length: number;\n\n  constructor(coder: TCoder, length: number) {\n    super('array', `[${coder.type}; ${length}]`, length * coder.encodedLength);\n    this.coder = coder;\n    this.length = length;\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    if (this.length !== value.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n\n    return concatWithDynamicData(Array.from(value).map((v) => this.coder.encode(v)));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    if (data.length < this.encodedLength || data.length > MAX_BYTES) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid array data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = Array(this.length)\n      .fill(0)\n      .map(() => {\n        let decoded;\n        [decoded, newOffset] = this.coder.decode(data, newOffset);\n        return decoded;\n      });\n\n    return [decodedValue as DecodedValueOf<TCoder>, newOffset];\n  }\n}\n","export const OPTION_CODER_TYPE = 'enum Option';\nexport const VEC_CODER_TYPE = 'struct Vec';\nexport const BYTES_CODER_TYPE = 'struct Bytes';\nexport const STD_STRING_CODER_TYPE = 'struct String';\nexport const stringRegEx = /str\\[(?<length>[0-9]+)\\]/;\nexport const arrayRegEx = /\\[(?<item>[\\w\\s\\\\[\\]]+);\\s*(?<length>[0-9]+)\\]/;\nexport const structRegEx = /^struct (?<name>\\w+)$/;\nexport const enumRegEx = /^enum (?<name>\\w+)$/;\nexport const tupleRegEx = /^\\((?<items>.*)\\)$/;\nexport const genericRegEx = /^generic (?<name>\\w+)$/;\n\nexport const WORD_SIZE = 8;\nexport const BYTES_32 = 32;\nexport const MAX_INPUTS = 255;\n\nexport const ASSET_ID_LEN = BYTES_32;\nexport const CONTRACT_ID_LEN = BYTES_32;\nexport const ADDRESS_LEN = BYTES_32;\nexport const NONCE_LEN = BYTES_32;\nexport const TX_LEN = WORD_SIZE * 4;\nexport const TX_POINTER_LEN = WORD_SIZE * 2;\nexport const MAX_BYTES = 2 ** 32 - 1; // Max u32\n\nexport const calculateVmTxMemory = ({ maxInputs }: { maxInputs: number }) =>\n  BYTES_32 + // Tx ID\n  WORD_SIZE + // Tx size\n  // Asset ID/Balance coin input pairs\n  maxInputs * (ASSET_ID_LEN + WORD_SIZE);\n\n// SCRIPT_FIXED_SIZE = 104\nexport const SCRIPT_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  WORD_SIZE + // Gas limit\n  WORD_SIZE + // Script size\n  WORD_SIZE + // Script data size\n  WORD_SIZE + // Policies\n  WORD_SIZE + // Inputs size\n  WORD_SIZE + // Outputs size\n  WORD_SIZE + // Witnesses size\n  BYTES_32; // Receipts root\n\n// INPUT_COIN_FIXED_SIZE = 176\nexport const INPUT_COIN_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  TX_LEN + // Utxo Length\n  WORD_SIZE + // Output Index\n  ADDRESS_LEN + // Owner\n  WORD_SIZE + // Amount\n  ASSET_ID_LEN + // Asset id\n  TX_POINTER_LEN + // TxPointer\n  WORD_SIZE + // Witnesses index\n  WORD_SIZE + // Maturity\n  WORD_SIZE + // Predicate size\n  WORD_SIZE + // Predicate data size\n  WORD_SIZE; // Predicate gas used\n\n// INPUT_MESSAGE_FIXED_SIZE = 168\nexport const INPUT_MESSAGE_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  ADDRESS_LEN + // Sender\n  ADDRESS_LEN + // Recipient\n  WORD_SIZE + // Amount\n  NONCE_LEN + // Nonce\n  WORD_SIZE + // witness_index\n  WORD_SIZE + // Data size\n  WORD_SIZE + // Predicate size\n  WORD_SIZE + // Predicate data size\n  WORD_SIZE; // Predicate gas used\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { concat, concatBytes } from '@fuel-ts/utils';\nimport { getBytesCopy, type BytesLike } from 'ethers';\n\nimport { U64Coder } from './coders/v0/u64';\nimport { BYTES_CODER_TYPE, VEC_CODER_TYPE, STD_STRING_CODER_TYPE, WORD_SIZE } from './constants';\n\nexport type DynamicData = {\n  [pointerIndex: number]: Uint8ArrayWithDynamicData;\n};\n\nexport type Uint8ArrayWithDynamicData = Uint8Array & {\n  dynamicData?: DynamicData;\n};\n\nconst VEC_PROPERTY_SPACE = 3; // ptr + cap + length\nexport const BASE_VECTOR_OFFSET = VEC_PROPERTY_SPACE * WORD_SIZE;\n\nconst RAW_SLICE_PROPERTY_SPACE = 2; // ptr + length\nexport const BASE_RAW_SLICE_OFFSET = RAW_SLICE_PROPERTY_SPACE * WORD_SIZE;\n\n// this is a fork of @ethersproject/bytes:concat\n// this collects individual dynamicData data and relocates it to top level\nexport function concatWithDynamicData(items: ReadonlyArray<BytesLike>): Uint8ArrayWithDynamicData {\n  const topLevelData: DynamicData = {};\n\n  let totalIndex = 0;\n  const objects = items.map((item) => {\n    const dynamicData = (item as Uint8ArrayWithDynamicData).dynamicData;\n    if (dynamicData) {\n      Object.entries(dynamicData).forEach(([pointerIndex, vData]) => {\n        topLevelData[parseInt(pointerIndex, 10) + totalIndex] = vData;\n      });\n    }\n\n    const byteArray = getBytesCopy(item);\n    totalIndex += byteArray.byteLength / WORD_SIZE;\n\n    return byteArray;\n  });\n\n  const length = objects.reduce((accum, item) => accum + item.length, 0);\n  const result: Uint8ArrayWithDynamicData = new Uint8Array(length);\n\n  objects.reduce((offset, object) => {\n    result.set(object, offset);\n    return offset + object.length;\n  }, 0);\n\n  // store vector data and pointer indices, but only if data exist\n  if (Object.keys(topLevelData).length) {\n    result.dynamicData = topLevelData;\n  }\n\n  return result;\n}\n\nexport function unpackDynamicData(\n  results: Uint8ArrayWithDynamicData,\n  baseOffset: number,\n  dataOffset: number\n): Uint8Array {\n  if (!results.dynamicData) {\n    return concat([results]);\n  }\n\n  let cumulativeDynamicByteLength = 0;\n  let updatedResults = results;\n  Object.entries(results.dynamicData).forEach(([pointerIndex, vData]) => {\n    // update value of pointer\n    const pointerOffset = parseInt(pointerIndex, 10) * WORD_SIZE;\n    const adjustedValue = new U64Coder().encode(\n      dataOffset + baseOffset + cumulativeDynamicByteLength\n    );\n    updatedResults.set(adjustedValue, pointerOffset);\n\n    // append dynamic data at the end\n    const dataToAppend = vData.dynamicData\n      ? // unpack child dynamic data\n        unpackDynamicData(\n          vData,\n          baseOffset,\n          dataOffset + vData.byteLength + cumulativeDynamicByteLength\n        )\n      : vData;\n    updatedResults = concat([updatedResults, dataToAppend]);\n\n    cumulativeDynamicByteLength += dataToAppend.byteLength;\n  });\n\n  return updatedResults;\n}\n\n/**\n * Turns:\n  Uint8Array(24) [\n    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 24\n  ]\n\n  Into:\n  Array [\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 1\n    ],\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 2\n    ],\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 24\n    ]\n  ]\n *\n */\nexport const chunkByLength = (data: Uint8Array, length = WORD_SIZE): Uint8Array[] => {\n  const chunks = [];\n  let offset = 0;\n  let chunk = data.slice(offset, offset + length);\n  while (chunk.length) {\n    chunks.push(chunk);\n    offset += length;\n    chunk = data.slice(offset, offset + length);\n  }\n\n  return chunks;\n};\n\n/**\n * Checks if a given type is a pointer type\n * See: https://github.com/FuelLabs/sway/issues/1368\n */\nexport const isPointerType = (type: string) => {\n  switch (type) {\n    case 'u8':\n    case 'u16':\n    case 'u32':\n    case 'u64':\n    case 'bool': {\n      return false;\n    }\n    default: {\n      return true;\n    }\n  }\n};\n\nexport const isHeapType = (type: string) =>\n  type === VEC_CODER_TYPE || type === BYTES_CODER_TYPE || type === STD_STRING_CODER_TYPE;\n\nexport function findOrThrow<T>(\n  arr: readonly T[],\n  predicate: (val: T) => boolean,\n  throwFn: () => never = () => {\n    throw new FuelError(ErrorCode.ELEMENT_NOT_FOUND, 'Element not found in the array.');\n  }\n): T {\n  const found = arr.find(predicate);\n  if (found === undefined) {\n    throwFn();\n  }\n\n  return found;\n}\n\n/**\n * Because some properties can be single-bytes, we need to pad them\n * with zeros until they are aligned to a word-sized increment.\n * This is the case for `tuple` and `struct` properties.\n * Please refer to packages/abi-coder/src/coders/abstract-coder.ts for more details\n */\nexport const isMultipleOfWordSize = (length: number) => length % WORD_SIZE === 0;\n\nexport const getWordSizePadding = (length: number) => WORD_SIZE - (length % WORD_SIZE);\n\nexport const rightPadToWordSize = (encoded: Uint8Array) => {\n  if (isMultipleOfWordSize(encoded.length)) {\n    return encoded;\n  }\n  const padding = new Uint8Array(WORD_SIZE - (encoded.length % WORD_SIZE));\n  return concatBytes([encoded, padding]);\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BN, BNInput } from '@fuel-ts/math';\nimport { bn, toBytes } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../../constants';\nimport { Coder } from '../abstract-coder';\n\nexport class U64Coder extends Coder<BNInput, BN> {\n  constructor() {\n    super('u64', 'u64', WORD_SIZE);\n  }\n\n  encode(value: BNInput): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value, WORD_SIZE);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n\n    return bytes;\n  }\n\n  decode(data: Uint8Array, offset: number): [BN, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid ${this.type} data size.`);\n    }\n\n    let bytes = data.slice(offset, offset + WORD_SIZE);\n    bytes = bytes.slice(0, WORD_SIZE);\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid ${this.type} byte data size.`);\n    }\n\n    return [bn(bytes), offset + WORD_SIZE];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toHex } from '@fuel-ts/math';\nimport { getBytesCopy } from 'ethers';\n\nimport { WORD_SIZE } from '../../constants';\nimport { Coder } from '../abstract-coder';\n\nexport class B256Coder extends Coder<string, string> {\n  constructor() {\n    super('b256', 'b256', WORD_SIZE * 4);\n  }\n\n  encode(value: string): Uint8Array {\n    let encodedValue;\n    try {\n      encodedValue = getBytesCopy(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    if (encodedValue.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    return encodedValue;\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b256 data size.`);\n    }\n\n    let bytes = data.slice(offset, offset + this.encodedLength);\n\n    const decoded = bn(bytes);\n    if (decoded.isZero()) {\n      bytes = new Uint8Array(32);\n    }\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b256 byte data size.`);\n    }\n\n    return [toHex(bytes, 32), offset + 32];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toHex } from '@fuel-ts/math';\nimport { getBytesCopy } from 'ethers';\n\nimport { WORD_SIZE } from '../../constants';\nimport { Coder } from '../abstract-coder';\n\nexport class B512Coder extends Coder<string, string> {\n  constructor() {\n    super('b512', 'struct B512', WORD_SIZE * 8);\n  }\n\n  encode(value: string): Uint8Array {\n    let encodedValue;\n    try {\n      encodedValue = getBytesCopy(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    if (encodedValue.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    return encodedValue;\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b512 data size.`);\n    }\n\n    let bytes = data.slice(offset, offset + this.encodedLength);\n\n    const decoded = bn(bytes);\n    if (decoded.isZero()) {\n      bytes = new Uint8Array(64);\n    }\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b512 byte data size.`);\n    }\n\n    return [toHex(bytes, this.encodedLength), offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toBytes } from '@fuel-ts/math';\n\nimport type { EncodingOptions } from '../abstract-coder';\nimport { Coder } from '../abstract-coder';\n\nexport class BooleanCoder extends Coder<boolean, boolean> {\n  paddingLength: number;\n  options: EncodingOptions;\n\n  constructor(\n    options: EncodingOptions = {\n      isSmallBytes: false,\n      isRightPadded: false,\n    }\n  ) {\n    const paddingLength = options.isSmallBytes ? 1 : 8;\n\n    super('boolean', 'boolean', paddingLength);\n\n    this.paddingLength = paddingLength;\n    this.options = options;\n  }\n\n  encode(value: boolean): Uint8Array {\n    const isTrueBool = value === true || value === false;\n\n    if (!isTrueBool) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid boolean value.`);\n    }\n\n    const output: Uint8Array = toBytes(value ? 1 : 0, this.paddingLength);\n\n    if (this.options.isRightPadded) {\n      return output.reverse();\n    }\n\n    return output;\n  }\n\n  decode(data: Uint8Array, offset: number): [boolean, number] {\n    if (data.length < this.paddingLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean data size.`);\n    }\n\n    let bytes;\n\n    if (this.options.isRightPadded) {\n      bytes = data.slice(offset, offset + 1);\n    } else {\n      bytes = data.slice(offset, offset + this.paddingLength);\n    }\n\n    const decodedValue = bn(bytes);\n    if (decodedValue.isZero()) {\n      return [false, offset + this.paddingLength];\n    }\n\n    if (!decodedValue.eq(bn(1))) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean value.`);\n    }\n\n    return [true, offset + this.paddingLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toNumber } from '@fuel-ts/math';\nimport { concat } from '@fuel-ts/utils';\nimport type { RequireExactlyOne } from 'type-fest';\n\nimport { concatWithDynamicData } from '../../utilities';\nimport type { TypesOfCoder } from '../abstract-coder';\nimport { Coder } from '../abstract-coder';\n\nimport { U64Coder } from './u64';\n\nexport type InputValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n}>;\nexport type DecodedValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n}>;\n\nconst isFullyNativeEnum = (enumCoders: { [s: string]: unknown } | ArrayLike<unknown>): boolean =>\n  Object.values(enumCoders).every(\n    // @ts-expect-error complicated types\n    ({ type, coders }) => type === '()' && JSON.stringify(coders) === JSON.stringify([])\n  );\n\nexport class EnumCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n  #caseIndexCoder: U64Coder;\n  #encodedValueSize: number;\n\n  constructor(name: string, coders: TCoders) {\n    const caseIndexCoder = new U64Coder();\n    const encodedValueSize = Object.values(coders).reduce(\n      (max, coder) => Math.max(max, coder.encodedLength),\n      0\n    );\n    super('enum', `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);\n    this.name = name;\n    this.coders = coders;\n    this.#caseIndexCoder = caseIndexCoder;\n    this.#encodedValueSize = encodedValueSize;\n  }\n\n  #encodeNativeEnum(value: string): Uint8Array {\n    const valueCoder = this.coders[value];\n    const encodedValue = valueCoder.encode([]);\n    const caseIndex = Object.keys(this.coders).indexOf(value);\n\n    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);\n    return concat([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (typeof value === 'string' && this.coders[value]) {\n      return this.#encodeNativeEnum(value);\n    }\n\n    const [caseKey, ...empty] = Object.keys(value);\n    if (!caseKey) {\n      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, 'A field for the case must be provided.');\n    }\n    if (empty.length !== 0) {\n      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, 'Only one field must be provided.');\n    }\n    const valueCoder = this.coders[caseKey];\n    const caseIndex = Object.keys(this.coders).indexOf(caseKey);\n    const encodedValue = valueCoder.encode(value[caseKey]);\n\n    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);\n    return concatWithDynamicData([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);\n  }\n\n  #decodeNativeEnum(caseKey: string, newOffset: number): [DecodedValueOf<TCoders>, number] {\n    return [caseKey as unknown as DecodedValueOf<TCoders>, newOffset];\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (data.length < this.#encodedValueSize) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid enum data size.`);\n    }\n\n    let newOffset = offset;\n\n    let decoded;\n    [decoded, newOffset] = new U64Coder().decode(data, newOffset);\n    const caseIndex = toNumber(decoded);\n    const caseKey = Object.keys(this.coders)[caseIndex];\n    if (!caseKey) {\n      throw new FuelError(\n        ErrorCode.INVALID_DECODE_VALUE,\n        `Invalid caseIndex \"${caseIndex}\". Valid cases: ${Object.keys(this.coders)}.`\n      );\n    }\n\n    const valueCoder = this.coders[caseKey];\n    const padding = this.#encodedValueSize - valueCoder.encodedLength;\n    newOffset += padding;\n    [decoded, newOffset] = valueCoder.decode(data, newOffset);\n\n    if (isFullyNativeEnum(this.coders)) {\n      return this.#decodeNativeEnum(caseKey, newOffset);\n    }\n\n    return [{ [caseKey]: decoded } as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toNumber, toBytes } from '@fuel-ts/math';\n\nimport type { EncodingOptions } from '../abstract-coder';\nimport { Coder } from '../abstract-coder';\n\ntype NumberCoderType = 'u8' | 'u16' | 'u32';\n\nexport class NumberCoder extends Coder<number, number> {\n  // This is to align the bits to the total bytes\n  // See https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#unsigned-integers\n  length: number;\n  paddingLength: number;\n  baseType: NumberCoderType;\n  options: EncodingOptions;\n\n  constructor(\n    baseType: NumberCoderType,\n    options: EncodingOptions = {\n      isSmallBytes: false,\n      isRightPadded: false,\n    }\n  ) {\n    const paddingLength = options.isSmallBytes && baseType === 'u8' ? 1 : 8;\n\n    super('number', baseType, paddingLength);\n    this.baseType = baseType;\n    switch (baseType) {\n      case 'u8':\n        this.length = 1;\n        break;\n      case 'u16':\n        this.length = 2;\n        break;\n      case 'u32':\n      default:\n        this.length = 4;\n        break;\n    }\n\n    this.paddingLength = paddingLength;\n    this.options = options;\n  }\n\n  encode(value: number | string): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}.`);\n    }\n\n    if (bytes.length > this.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);\n    }\n\n    const output = toBytes(bytes, this.paddingLength);\n\n    if (this.baseType !== 'u8') {\n      return output;\n    }\n\n    return this.options.isRightPadded ? output.reverse() : output;\n  }\n\n  private decodeU8(data: Uint8Array, offset: number): [number, number] {\n    let bytes;\n    if (this.options.isRightPadded) {\n      bytes = data.slice(offset, offset + 1);\n    } else {\n      bytes = data.slice(offset, offset + this.paddingLength);\n      bytes = bytes.slice(this.paddingLength - this.length, this.paddingLength);\n    }\n\n    return [toNumber(bytes), offset + this.paddingLength];\n  }\n\n  decode(data: Uint8Array, offset: number): [number, number] {\n    if (data.length < this.paddingLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number data size.`);\n    }\n\n    if (this.baseType === 'u8') {\n      return this.decodeU8(data, offset);\n    }\n\n    let bytes = data.slice(offset, offset + this.paddingLength);\n    bytes = bytes.slice(8 - this.length, 8);\n\n    if (bytes.length !== this.paddingLength - (this.paddingLength - this.length)) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number byte data size.`);\n    }\n\n    return [toNumber(bytes), offset + 8];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { concat } from '@fuel-ts/utils';\nimport { toUtf8Bytes, toUtf8String } from 'ethers';\n\nimport { Coder } from '../abstract-coder';\n\nexport class StringCoder<TLength extends number = number> extends Coder<string, string> {\n  length: TLength;\n  #paddingLength: number;\n\n  constructor(length: TLength) {\n    let paddingLength = (8 - length) % 8;\n    paddingLength = paddingLength < 0 ? paddingLength + 8 : paddingLength;\n    super('string', `str[${length}]`, length + paddingLength);\n    this.length = length;\n    this.#paddingLength = paddingLength;\n  }\n\n  encode(value: string): Uint8Array {\n    if (this.length !== value.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Value length mismatch during encode.`);\n    }\n\n    const encoded = toUtf8Bytes(value);\n    const padding = new Uint8Array(this.#paddingLength);\n    return concat([encoded, padding]);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string data size.`);\n    }\n\n    const bytes = data.slice(offset, offset + this.length);\n\n    if (bytes.length !== this.length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string byte data size.`);\n    }\n\n    const value = toUtf8String(bytes);\n\n    const padding = this.#paddingLength;\n    return [value, offset + this.length + padding];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport {\n  concatWithDynamicData,\n  getWordSizePadding,\n  isMultipleOfWordSize,\n  rightPadToWordSize,\n} from '../../utilities';\nimport type { TypesOfCoder } from '../abstract-coder';\nimport { Coder } from '../abstract-coder';\n\nimport { OptionCoder } from './option';\n\ntype InputValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class StructCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n\n  constructor(name: string, coders: TCoders) {\n    const encodedLength = Object.values(coders).reduce(\n      (acc, coder) => acc + coder.encodedLength,\n      0\n    );\n    super('struct', `struct ${name}`, encodedLength);\n    this.name = name;\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>) {\n    const encodedFields = Object.keys(this.coders).map((fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      const fieldValue = value[fieldName];\n\n      if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {\n        throw new FuelError(\n          ErrorCode.ENCODE_ERROR,\n          `Invalid ${this.type}. Field \"${fieldName}\" not present.`\n        );\n      }\n\n      const encoded = fieldCoder.encode(fieldValue);\n\n      if (!isMultipleOfWordSize(encoded.length)) {\n        return rightPadToWordSize(encoded);\n      }\n\n      return encoded;\n    });\n\n    return concatWithDynamicData([concatWithDynamicData(encodedFields)]);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid struct data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      let decoded;\n      [decoded, newOffset] = fieldCoder.decode(data, newOffset);\n\n      if (!isMultipleOfWordSize(newOffset)) {\n        newOffset += getWordSizePadding(newOffset);\n      }\n\n      // eslint-disable-next-line no-param-reassign\n      obj[fieldName as keyof DecodedValueOf<TCoders>] = decoded;\n      return obj;\n    }, {} as DecodedValueOf<TCoders>);\n\n    return [decodedValue, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { Coder } from '../abstract-coder';\n\nimport type { InputValueOf, DecodedValueOf } from './enum';\nimport { EnumCoder } from './enum';\n\ntype SwayOption<T> = { None: [] } | { Some: T };\nexport type Option<T> = T | undefined;\n\nexport class OptionCoder<TCoders extends Record<string, Coder>> extends EnumCoder<TCoders> {\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    const result = super.encode(this.toSwayOption(value) as unknown as InputValueOf<TCoders>);\n    return result;\n  }\n\n  toSwayOption(input: InputValueOf<TCoders>): SwayOption<unknown> {\n    if (input !== undefined) {\n      return { Some: input };\n    }\n\n    return { None: [] };\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    // An empty option will be one less than the expected encoded length\n    if (data.length < this.encodedLength - 1) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid option data size.`);\n    }\n\n    const [decoded, newOffset] = super.decode(data, offset);\n    return [this.toOption(decoded) as DecodedValueOf<TCoders>, newOffset];\n  }\n\n  toOption(output?: DecodedValueOf<TCoders>): Option<unknown> {\n    if (output && 'Some' in output) {\n      return output.Some;\n    }\n\n    return undefined;\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport {\n  concatWithDynamicData,\n  getWordSizePadding,\n  isMultipleOfWordSize,\n  rightPadToWordSize,\n} from '../../utilities';\nimport type { TypesOfCoder } from '../abstract-coder';\nimport { Coder } from '../abstract-coder';\n\ntype InputValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class TupleCoder<TCoders extends Coder[]> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  coders: TCoders;\n\n  constructor(coders: TCoders) {\n    const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);\n    super('tuple', `(${coders.map((coder) => coder.type).join(', ')})`, encodedLength);\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (this.coders.length !== value.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n\n    return concatWithDynamicData(\n      this.coders.map((coder, i) => {\n        const encoded = coder.encode(value[i]);\n        if (!isMultipleOfWordSize(encoded.length)) {\n          return rightPadToWordSize(encoded);\n        }\n        return encoded;\n      })\n    );\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid tuple data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = this.coders.map((coder) => {\n      let decoded;\n      [decoded, newOffset] = coder.decode(data, newOffset);\n\n      if (!isMultipleOfWordSize(newOffset)) {\n        newOffset += getWordSizePadding(newOffset);\n      }\n\n      return decoded;\n    });\n\n    return [decodedValue as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport { MAX_BYTES } from '../../constants';\nimport type { Uint8ArrayWithDynamicData } from '../../utilities';\nimport { concatWithDynamicData, BASE_VECTOR_OFFSET, chunkByLength } from '../../utilities';\nimport type { TypesOfCoder } from '../abstract-coder';\nimport { Coder } from '../abstract-coder';\n\nimport { U64Coder } from './u64';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport class VecCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n\n  constructor(coder: TCoder) {\n    super('struct', `struct Vec`, coder.encodedLength + BASE_VECTOR_OFFSET);\n    this.coder = coder;\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const parts: Uint8Array[] = [];\n\n    // pointer (ptr)\n    const pointer: Uint8ArrayWithDynamicData = new U64Coder().encode(BASE_VECTOR_OFFSET);\n    // pointer dynamicData, encode the vector now and attach to its pointer\n    pointer.dynamicData = {\n      0: concatWithDynamicData(Array.from(value).map((v) => this.coder.encode(v))),\n    };\n\n    parts.push(pointer);\n\n    // capacity (cap)\n    parts.push(new U64Coder().encode(value.length));\n\n    // length (len)\n    parts.push(new U64Coder().encode(value.length));\n\n    return concatWithDynamicData(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    if (data.length < BASE_VECTOR_OFFSET || data.length > MAX_BYTES) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec data size.`);\n    }\n\n    const len = data.slice(16, 24);\n    const encodedLength = bn(new U64Coder().decode(len, 0)[0]).toNumber();\n    const vectorRawDataLength = encodedLength * this.coder.encodedLength;\n    const vectorRawData = data.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + vectorRawDataLength);\n\n    if (vectorRawData.length !== vectorRawDataLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec byte data size.`);\n    }\n\n    return [\n      chunkByLength(vectorRawData, this.coder.encodedLength).map(\n        (chunk) => this.coder.decode(chunk, 0)[0]\n      ),\n      offset + BASE_VECTOR_OFFSET,\n    ];\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { getBytesCopy, type BytesLike } from 'ethers';\n\nimport { AbiCoder } from './abi-coder';\nimport type { InputValue } from './coders/abstract-coder';\nimport { FunctionFragment } from './function-fragment';\nimport type { JsonAbi, JsonAbiConfigurable } from './json-abi';\nimport { findOrThrow } from './utilities';\n\nexport class Interface<TAbi extends JsonAbi = JsonAbi> {\n  readonly functions!: Record<string, FunctionFragment>;\n\n  readonly configurables: Record<string, JsonAbiConfigurable>;\n  /*\n  TODO: Refactor so that there's no need for externalLoggedTypes\n\n  This is dedicated to external contracts added via `<base-invocation-scope.ts>.addContracts()` method.\n  This is used to decode logs from contracts other than the main contract\n  we're interacting with.\n  */\n  private externalLoggedTypes: Record<string, Interface>;\n  readonly jsonAbi: TAbi;\n\n  constructor(jsonAbi: TAbi) {\n    this.jsonAbi = jsonAbi;\n\n    this.externalLoggedTypes = {};\n\n    this.functions = Object.fromEntries(\n      this.jsonAbi.functions.map((x) => [x.name, new FunctionFragment(this.jsonAbi, x.name)])\n    );\n\n    this.configurables = Object.fromEntries(this.jsonAbi.configurables.map((x) => [x.name, x]));\n  }\n\n  /**\n   * Returns function fragment for a dynamic input.\n   * @param nameOrSignatureOrSelector - name (e.g. 'transfer'), signature (e.g. 'transfer(address,uint256)') or selector (e.g. '0x00000000a9059cbb') of the function fragment\n   */\n  getFunction(nameOrSignatureOrSelector: string): FunctionFragment {\n    const fn = Object.values<FunctionFragment>(this.functions).find(\n      (f) =>\n        f.name === nameOrSignatureOrSelector ||\n        f.signature === nameOrSignatureOrSelector ||\n        f.selector === nameOrSignatureOrSelector\n    );\n\n    if (fn !== undefined) {\n      return fn;\n    }\n\n    throw new FuelError(\n      ErrorCode.FUNCTION_NOT_FOUND,\n      `function ${nameOrSignatureOrSelector} not found: ${JSON.stringify(fn)}.`\n    );\n  }\n\n  decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    if (!fragment) {\n      throw new FuelError(ErrorCode.FRAGMENT_NOT_FOUND, 'Fragment not found.');\n    }\n\n    return fragment.decodeArguments(data);\n  }\n\n  encodeFunctionData(\n    functionFragment: FunctionFragment | string,\n    values: Array<InputValue>,\n    offset = 0\n  ): Uint8Array {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    if (!fragment) {\n      throw new FuelError(ErrorCode.FRAGMENT_NOT_FOUND, 'Fragment not found.');\n    }\n\n    return fragment.encodeArguments(values, offset);\n  }\n\n  // Decode the result of a function call\n  decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    return fragment.decodeOutput(data);\n  }\n\n  decodeLog(data: BytesLike, logId: number, receiptId: string): any {\n    const isExternalLoggedType = this.externalLoggedTypes[receiptId];\n    if (isExternalLoggedType) {\n      const externalInterface = this.externalLoggedTypes[receiptId];\n      return externalInterface.decodeLog(data, logId, receiptId);\n    }\n\n    const { loggedType } = findOrThrow(this.jsonAbi.loggedTypes, (type) => type.logId === logId);\n\n    return AbiCoder.decode(this.jsonAbi, loggedType, getBytesCopy(data), 0, {\n      version: this.jsonAbi.encoding,\n    });\n  }\n\n  updateExternalLoggedTypes(id: string, loggedTypes: Interface) {\n    this.externalLoggedTypes[id] = loggedTypes;\n  }\n\n  encodeConfigurable(name: string, value: InputValue) {\n    const configurable = findOrThrow(\n      this.jsonAbi.configurables,\n      (c) => c.name === name,\n      () => {\n        throw new FuelError(\n          ErrorCode.CONFIGURABLE_NOT_FOUND,\n          `A configurable with the '${name}' was not found in the ABI.`\n        );\n      }\n    );\n\n    return AbiCoder.encode(this.jsonAbi, configurable.configurableType, value, {\n      isRightPadded: true,\n    });\n  }\n\n  getTypeById(typeId: number) {\n    return findOrThrow(\n      this.jsonAbi.types,\n      (t) => t.typeId === typeId,\n      () => {\n        throw new FuelError(\n          ErrorCode.TYPE_NOT_FOUND,\n          `Type with typeId '${typeId}' doesn't exist in the ABI.`\n        );\n      }\n    );\n  }\n}\n","// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { DecodedValue, InputValue, Coder, EncodingOptions } from './coders/abstract-coder';\nimport { ArrayCoder } from './coders/v0/array';\nimport { B256Coder } from './coders/v0/b256';\nimport { B512Coder } from './coders/v0/b512';\nimport { BooleanCoder } from './coders/v0/boolean';\nimport { ByteCoder } from './coders/v0/byte';\nimport { EnumCoder } from './coders/v0/enum';\nimport { NumberCoder } from './coders/v0/number';\nimport { OptionCoder } from './coders/v0/option';\nimport { RawSliceCoder } from './coders/v0/raw-slice';\nimport { StdStringCoder } from './coders/v0/stdString';\nimport { StringCoder } from './coders/v0/string';\nimport { StructCoder } from './coders/v0/struct';\nimport { TupleCoder } from './coders/v0/tuple';\nimport { U64Coder } from './coders/v0/u64';\nimport { VecCoder } from './coders/v0/vec';\nimport { BooleanCoder as BooleanCoderV1 } from './coders/v1/boolean';\nimport { ByteCoder as ByteCoderV1 } from './coders/v1/byte';\nimport { EnumCoder as EnumCoderV1 } from './coders/v1/enum';\nimport { NumberCoder as NumberCoderV1 } from './coders/v1/number';\nimport { RawSliceCoder as RawSliceCoderV1 } from './coders/v1/raw-slice';\nimport { StdStringCoder as StdStringCoderV1 } from './coders/v1/std-string';\nimport { StringCoder as StringCoderV1 } from './coders/v1/string';\nimport { StructCoder as StructCoderV1 } from './coders/v1/struct';\nimport { TupleCoder as TupleCoderV1 } from './coders/v1/tuple';\nimport { VecCoder as VecCoderV1 } from './coders/v1/vec';\nimport {\n  arrayRegEx,\n  enumRegEx,\n  stringRegEx,\n  structRegEx,\n  tupleRegEx,\n  OPTION_CODER_TYPE,\n  VEC_CODER_TYPE,\n  BYTES_CODER_TYPE,\n  STD_STRING_CODER_TYPE,\n} from './constants';\nimport type { JsonAbi, JsonAbiArgument } from './json-abi';\nimport { ResolvedAbiType } from './resolved-abi-type';\nimport { findOrThrow } from './utilities';\n\nexport abstract class AbiCoder {\n  static getCoder(\n    abi: JsonAbi,\n    argument: JsonAbiArgument,\n    options: EncodingOptions = {\n      isSmallBytes: false,\n    }\n  ): Coder {\n    const resolvedAbiType = new ResolvedAbiType(abi, argument);\n\n    return AbiCoder.getCoderImpl(resolvedAbiType, options);\n  }\n\n  static encode(\n    abi: JsonAbi,\n    argument: JsonAbiArgument,\n    value: InputValue,\n    options?: EncodingOptions\n  ) {\n    return this.getCoder(abi, argument, options).encode(value);\n  }\n\n  static decode(\n    abi: JsonAbi,\n    argument: JsonAbiArgument,\n    data: Uint8Array,\n    offset: number,\n    options?: EncodingOptions\n  ): [DecodedValue | undefined, number] {\n    return this.getCoder(abi, argument, options).decode(data, offset) as [\n      DecodedValue | undefined,\n      number,\n    ];\n  }\n\n  private static getCoderImpl(\n    resolvedAbiType: ResolvedAbiType,\n    options: EncodingOptions = {\n      isSmallBytes: false,\n    }\n  ): Coder {\n    const { version } = options;\n\n    switch (resolvedAbiType.type) {\n      case 'u8':\n      case 'u16':\n      case 'u32':\n        return version\n          ? new NumberCoderV1(resolvedAbiType.type)\n          : new NumberCoder(resolvedAbiType.type, options);\n      case 'u64':\n      case 'raw untyped ptr':\n        return new U64Coder();\n      case 'raw untyped slice':\n        return version ? new RawSliceCoderV1() : new RawSliceCoder();\n      case 'bool':\n        return version ? new BooleanCoderV1() : new BooleanCoder(options);\n      case 'b256':\n        return new B256Coder();\n      case 'struct B512':\n        return new B512Coder();\n      case BYTES_CODER_TYPE:\n        return version ? new ByteCoderV1() : new ByteCoder();\n      case STD_STRING_CODER_TYPE:\n        return version ? new StdStringCoderV1() : new StdStringCoder();\n      default:\n        break;\n    }\n\n    const stringMatch = stringRegEx.exec(resolvedAbiType.type)?.groups;\n    if (stringMatch) {\n      const length = parseInt(stringMatch.length, 10);\n\n      return version ? new StringCoderV1(length) : new StringCoder(length);\n    }\n\n    // ABI types underneath MUST have components by definition\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const components = resolvedAbiType.components!;\n\n    const arrayMatch = arrayRegEx.exec(resolvedAbiType.type)?.groups;\n    if (arrayMatch) {\n      const length = parseInt(arrayMatch.length, 10);\n      const arg = components[0];\n      if (!arg) {\n        throw new FuelError(\n          ErrorCode.INVALID_COMPONENT,\n          `The provided Array type is missing an item of 'component'.`\n        );\n      }\n\n      const arrayElementCoder = AbiCoder.getCoderImpl(arg, { version, isSmallBytes: true });\n      return new ArrayCoder(arrayElementCoder, length);\n    }\n\n    if (resolvedAbiType.type === VEC_CODER_TYPE) {\n      const arg = findOrThrow(components, (c) => c.name === 'buf').originalTypeArguments?.[0];\n      if (!arg) {\n        throw new FuelError(\n          ErrorCode.INVALID_COMPONENT,\n          `The provided Vec type is missing the 'type argument'.`\n        );\n      }\n      const argType = new ResolvedAbiType(resolvedAbiType.abi, arg);\n\n      const itemCoder = AbiCoder.getCoderImpl(argType, { version, isSmallBytes: true });\n      return version ? new VecCoderV1(itemCoder) : new VecCoder(itemCoder);\n    }\n\n    const structMatch = structRegEx.exec(resolvedAbiType.type)?.groups;\n    if (structMatch) {\n      const coders = AbiCoder.getCoders(components, { version, isRightPadded: true });\n      return version\n        ? new StructCoderV1(structMatch.name, coders)\n        : new StructCoder(structMatch.name, coders);\n    }\n\n    const enumMatch = enumRegEx.exec(resolvedAbiType.type)?.groups;\n    if (enumMatch) {\n      const coders = AbiCoder.getCoders(components, { version });\n\n      const isOptionEnum = resolvedAbiType.type === OPTION_CODER_TYPE;\n      if (isOptionEnum) {\n        return new OptionCoder(enumMatch.name, coders);\n      }\n      return version\n        ? new EnumCoderV1(enumMatch.name, coders)\n        : new EnumCoder(enumMatch.name, coders);\n    }\n\n    const tupleMatch = tupleRegEx.exec(resolvedAbiType.type)?.groups;\n    if (tupleMatch) {\n      const coders = components.map((component) =>\n        AbiCoder.getCoderImpl(component, { version, isRightPadded: true })\n      );\n      return version ? new TupleCoderV1(coders) : new TupleCoder(coders);\n    }\n\n    if (resolvedAbiType.type === 'str') {\n      throw new FuelError(\n        ErrorCode.INVALID_DATA,\n        'String slices can not be decoded from logs. Convert the slice to `str[N]` with `__to_str_array`'\n      );\n    }\n\n    throw new FuelError(\n      ErrorCode.CODER_NOT_FOUND,\n      `Coder not found: ${JSON.stringify(resolvedAbiType)}.`\n    );\n  }\n\n  private static getCoders(components: readonly ResolvedAbiType[], options: EncodingOptions) {\n    return components.reduce((obj, component) => {\n      const o: Record<string, Coder> = obj;\n\n      o[component.name] = AbiCoder.getCoderImpl(component, options);\n      return o;\n    }, {});\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { concat } from '@fuel-ts/utils';\n\nimport { WORD_SIZE } from '../../constants';\nimport type { Uint8ArrayWithDynamicData } from '../../utilities';\nimport { BASE_VECTOR_OFFSET, concatWithDynamicData } from '../../utilities';\nimport { Coder } from '../abstract-coder';\n\nimport { U64Coder } from './u64';\n\nexport class ByteCoder extends Coder<number[], Uint8Array> {\n  static memorySize = 1;\n  constructor() {\n    super('struct', 'struct Bytes', BASE_VECTOR_OFFSET);\n  }\n\n  encode(value: number[]): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const parts: Uint8Array[] = [];\n\n    // pointer (ptr)\n    const pointer: Uint8ArrayWithDynamicData = new U64Coder().encode(BASE_VECTOR_OFFSET);\n\n    // pointer dynamicData, encode the byte vector now and attach to its pointer\n    const data = this.#getPaddedData(value);\n    pointer.dynamicData = {\n      0: concatWithDynamicData([data]),\n    };\n\n    parts.push(pointer);\n\n    // capacity (cap)\n    parts.push(new U64Coder().encode(data.byteLength));\n\n    // length (len)\n    parts.push(new U64Coder().encode(value.length));\n\n    return concatWithDynamicData(parts);\n  }\n\n  #getPaddedData(value: number[]): Uint8Array {\n    const data: Uint8Array[] = [Uint8Array.from(value)];\n\n    const paddingLength = (WORD_SIZE - (value.length % WORD_SIZE)) % WORD_SIZE;\n    if (paddingLength) {\n      data.push(new Uint8Array(paddingLength));\n    }\n\n    return concat(data);\n  }\n\n  decode(data: Uint8Array, offset: number): [Uint8Array, number] {\n    if (data.length < BASE_VECTOR_OFFSET) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid byte data size.`);\n    }\n\n    const len = data.slice(16, 24);\n    const encodedLength = bn(new U64Coder().decode(len, 0)[0]).toNumber();\n    const byteData = data.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + encodedLength);\n\n    if (byteData.length !== encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid bytes byte data size.`);\n    }\n\n    return [byteData, offset + BASE_VECTOR_OFFSET];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { Uint8ArrayWithDynamicData } from '../../utilities';\nimport { BASE_RAW_SLICE_OFFSET, concatWithDynamicData } from '../../utilities';\nimport { Coder } from '../abstract-coder';\n\nimport { ArrayCoder } from './array';\nimport { NumberCoder } from './number';\nimport { U64Coder } from './u64';\n\nexport class RawSliceCoder extends Coder<number[], number[]> {\n  constructor() {\n    super('raw untyped slice', 'raw untyped slice', BASE_RAW_SLICE_OFFSET);\n  }\n\n  encode(value: number[]): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const parts: Uint8Array[] = [];\n    const coder = new NumberCoder('u8', { isSmallBytes: true });\n\n    // pointer (ptr)\n    const pointer: Uint8ArrayWithDynamicData = new U64Coder().encode(BASE_RAW_SLICE_OFFSET);\n\n    // pointer dynamicData, encode the vector now and attach to its pointer\n    pointer.dynamicData = {\n      0: concatWithDynamicData(value.map((v) => coder.encode(v))),\n    };\n\n    parts.push(pointer);\n\n    // length (len)\n    parts.push(new U64Coder().encode(value.length));\n\n    return concatWithDynamicData(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [number[], number] {\n    const dataBytes = data.slice(offset);\n    const internalCoder = new ArrayCoder(\n      new NumberCoder('u8', { isSmallBytes: true }),\n      dataBytes.length\n    );\n    const [decodedValue] = internalCoder.decode(dataBytes, 0);\n\n    return [decodedValue, offset + dataBytes.length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { concat } from '@fuel-ts/utils';\nimport { toUtf8Bytes, toUtf8String } from 'ethers';\n\nimport { WORD_SIZE } from '../../constants';\nimport type { Uint8ArrayWithDynamicData } from '../../utilities';\nimport { BASE_VECTOR_OFFSET, concatWithDynamicData } from '../../utilities';\nimport { Coder } from '../abstract-coder';\n\nimport { U64Coder } from './u64';\n\nexport class StdStringCoder extends Coder<string, string> {\n  static memorySize = 1;\n  constructor() {\n    super('struct', 'struct String', 1);\n  }\n\n  encode(value: string): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    // pointer (ptr)\n    const pointer: Uint8ArrayWithDynamicData = new U64Coder().encode(BASE_VECTOR_OFFSET);\n\n    // pointer dynamicData, encode the string vector now and attach to its pointer\n    const data = this.#getPaddedData(value);\n    pointer.dynamicData = {\n      0: concatWithDynamicData([data]),\n    };\n\n    parts.push(pointer);\n\n    // capacity (cap)\n    parts.push(new U64Coder().encode(data.byteLength));\n\n    // length (len)\n    parts.push(new U64Coder().encode(value.length));\n\n    return concatWithDynamicData(parts);\n  }\n\n  #getPaddedData(value: string): Uint8Array {\n    const data: Uint8Array[] = [toUtf8Bytes(value)];\n\n    const paddingLength = (WORD_SIZE - (value.length % WORD_SIZE)) % WORD_SIZE;\n    if (paddingLength) {\n      data.push(new Uint8Array(paddingLength));\n    }\n\n    return concat(data);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string data size.`);\n    }\n\n    const len = data.slice(16, 24);\n    const encodedLength = bn(new U64Coder().decode(len, 0)[0]).toNumber();\n    const byteData = data.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + encodedLength);\n\n    if (byteData.length !== encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string byte data size.`);\n    }\n\n    const value = toUtf8String(byteData);\n    return [value, offset + BASE_VECTOR_OFFSET];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toBytes } from '@fuel-ts/math';\n\nimport { Coder } from '../abstract-coder';\n\nexport class BooleanCoder extends Coder<boolean, boolean> {\n  constructor() {\n    super('boolean', 'boolean', 1);\n  }\n\n  encode(value: boolean): Uint8Array {\n    const isTrueBool = value === true || value === false;\n\n    if (!isTrueBool) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid boolean value.`);\n    }\n\n    return toBytes(value ? 1 : 0, this.encodedLength);\n  }\n\n  decode(data: Uint8Array, offset: number): [boolean, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean data size.`);\n    }\n\n    const bytes = bn(data.slice(offset, offset + this.encodedLength));\n\n    if (bytes.isZero()) {\n      return [false, offset + this.encodedLength];\n    }\n\n    if (!bytes.eq(bn(1))) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean value.`);\n    }\n\n    return [true, offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../../constants';\nimport { Coder } from '../abstract-coder';\nimport { U64Coder } from '../v0/u64';\n\nexport class ByteCoder extends Coder<number[], Uint8Array> {\n  static memorySize = 1;\n  constructor() {\n    super('struct', 'struct Bytes', 1);\n  }\n\n  encode(_value: number[]): Uint8Array {\n    throw new FuelError(ErrorCode.ENCODE_ERROR, `Bytes encode unsupported in v1`);\n  }\n\n  decode(data: Uint8Array, offset: number): [Uint8Array, number] {\n    if (data.length < WORD_SIZE) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid byte data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new U64Coder().decode(lengthBytes, 0)[0]).toNumber();\n    const dataLength = length * this.encodedLength;\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + dataLength);\n\n    if (dataBytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid bytes byte data size.`);\n    }\n\n    return [dataBytes, offset + dataLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toNumber } from '@fuel-ts/math';\nimport type { RequireExactlyOne } from 'type-fest';\n\nimport { WORD_SIZE } from '../../constants';\nimport type { TypesOfCoder } from '../abstract-coder';\nimport { Coder } from '../abstract-coder';\nimport { U64Coder } from '../v0/u64';\n\nexport type InputValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n}>;\nexport type DecodedValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n}>;\n\nconst isFullyNativeEnum = (enumCoders: { [s: string]: unknown } | ArrayLike<unknown>): boolean =>\n  Object.values(enumCoders).every(\n    // @ts-expect-error complicated types\n    ({ type, coders }) => type === '()' && JSON.stringify(coders) === JSON.stringify([])\n  );\n\nexport class EnumCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n  #caseIndexCoder: U64Coder;\n  #encodedValueSize: number;\n\n  constructor(name: string, coders: TCoders) {\n    const caseIndexCoder = new U64Coder();\n    const encodedValueSize = Object.values(coders).reduce(\n      (max, coder) => Math.max(max, coder.encodedLength),\n      0\n    );\n    super('enum', `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);\n    this.name = name;\n    this.coders = coders;\n    this.#caseIndexCoder = caseIndexCoder;\n    this.#encodedValueSize = encodedValueSize;\n  }\n\n  encode(_value: InputValueOf<TCoders>): Uint8Array {\n    throw new FuelError(ErrorCode.ENCODE_ERROR, `Enum encode unsupported in v1`);\n  }\n\n  #decodeNativeEnum(caseKey: string, newOffset: number): [DecodedValueOf<TCoders>, number] {\n    return [caseKey as unknown as DecodedValueOf<TCoders>, newOffset];\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (data.length < this.#encodedValueSize) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid enum data size.`);\n    }\n\n    const caseBytes = new U64Coder().decode(data, offset)[0];\n    const caseIndex = toNumber(caseBytes);\n    const caseKey = Object.keys(this.coders)[caseIndex];\n    if (!caseKey) {\n      throw new FuelError(\n        ErrorCode.INVALID_DECODE_VALUE,\n        `Invalid caseIndex \"${caseIndex}\". Valid cases: ${Object.keys(this.coders)}.`\n      );\n    }\n\n    const valueCoder = this.coders[caseKey];\n    const offsetAndCase = offset + WORD_SIZE;\n\n    const [decoded, newOffset] = valueCoder.decode(data, offsetAndCase);\n\n    if (isFullyNativeEnum(this.coders)) {\n      return this.#decodeNativeEnum(caseKey, newOffset);\n    }\n\n    return [{ [caseKey]: decoded } as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toNumber, toBytes } from '@fuel-ts/math';\n\nimport { Coder } from '../abstract-coder';\n\ntype NumberCoderType = 'u8' | 'u16' | 'u32' | 'u64';\n\nconst getLength = (baseType: NumberCoderType): number => {\n  switch (baseType) {\n    case 'u8':\n      return 1;\n    case 'u16':\n      return 2;\n    case 'u32':\n      return 4;\n    default:\n      throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Invalid number type: ${baseType}`);\n  }\n};\n\nexport class NumberCoder extends Coder<number, number> {\n  length: number;\n  baseType: NumberCoderType;\n\n  constructor(baseType: NumberCoderType) {\n    const length = getLength(baseType);\n    super('number', baseType, length);\n    this.baseType = baseType;\n    this.length = length;\n  }\n\n  encode(value: number | string): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}.`);\n    }\n\n    if (bytes.length > this.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);\n    }\n\n    return toBytes(bytes, this.length);\n  }\n\n  decode(data: Uint8Array, offset: number): [number, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number data size.`);\n    }\n\n    const bytes = data.slice(offset, offset + this.length);\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number byte data size.`);\n    }\n\n    return [toNumber(bytes), offset + this.length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../../constants';\nimport { Coder } from '../abstract-coder';\nimport { ArrayCoder } from '../v0/array';\nimport { U64Coder } from '../v0/u64';\n\nimport { NumberCoder } from './number';\n\nexport class RawSliceCoder extends Coder<number[], number[]> {\n  constructor() {\n    super('raw untyped slice', 'raw untyped slice', WORD_SIZE);\n  }\n\n  encode(_value: number[]): Uint8Array {\n    throw new FuelError(ErrorCode.ENCODE_ERROR, `Raw slice encode unsupported in v1`);\n  }\n\n  decode(data: Uint8Array, offset: number): [number[], number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid raw slice data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new U64Coder().decode(lengthBytes, 0)[0]).toNumber();\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n\n    if (dataBytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid raw slice byte data size.`);\n    }\n\n    const internalCoder = new ArrayCoder(new NumberCoder('u8'), length);\n    const [decodedValue] = internalCoder.decode(dataBytes, 0);\n\n    return [decodedValue, offsetAndLength + length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { toUtf8String } from 'ethers';\n\nimport { WORD_SIZE } from '../../constants';\nimport { Coder } from '../abstract-coder';\nimport { U64Coder } from '../v0/u64';\n\nexport class StdStringCoder extends Coder<string, string> {\n  static memorySize = 1;\n  constructor() {\n    super('struct', 'struct String', WORD_SIZE);\n  }\n\n  encode(_value: string): Uint8Array {\n    throw new FuelError(ErrorCode.ENCODE_ERROR, `StdString encode unsupported in v1`);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new U64Coder().decode(lengthBytes, 0)[0]).toNumber();\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n\n    if (dataBytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string byte data size.`);\n    }\n\n    return [toUtf8String(dataBytes), offsetAndLength + length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toUtf8Bytes, toUtf8String } from 'ethers';\n\nimport { Coder } from '../abstract-coder';\n\nexport class StringCoder<TLength extends number = number> extends Coder<string, string> {\n  constructor(length: TLength) {\n    super('string', `str[${length}]`, length);\n  }\n\n  encode(value: string): Uint8Array {\n    if (value.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Value length mismatch during encode.`);\n    }\n\n    return toUtf8Bytes(value);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string data size.`);\n    }\n\n    const bytes = data.slice(offset, offset + this.encodedLength);\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string byte data size.`);\n    }\n\n    return [toUtf8String(bytes), offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { TypesOfCoder } from '../abstract-coder';\nimport { Coder } from '../abstract-coder';\n\ntype InputValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class StructCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n\n  constructor(name: string, coders: TCoders) {\n    const encodedLength = Object.values(coders).reduce(\n      (acc, coder) => acc + coder.encodedLength,\n      0\n    );\n    super('struct', `struct ${name}`, encodedLength);\n    this.name = name;\n    this.coders = coders;\n  }\n\n  encode(_value: InputValueOf<TCoders>): Uint8Array {\n    throw new FuelError(ErrorCode.ENCODE_ERROR, `Struct encode unsupported in v1`);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid struct data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      let decoded;\n      [decoded, newOffset] = fieldCoder.decode(data, newOffset);\n\n      // eslint-disable-next-line no-param-reassign\n      obj[fieldName as keyof DecodedValueOf<TCoders>] = decoded;\n      return obj;\n    }, {} as DecodedValueOf<TCoders>);\n\n    return [decodedValue, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { TypesOfCoder } from '../abstract-coder';\nimport { Coder } from '../abstract-coder';\n\ntype InputValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class TupleCoder<TCoders extends Coder[]> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  coders: TCoders;\n\n  constructor(coders: TCoders) {\n    const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);\n    super('tuple', `(${coders.map((coder) => coder.type).join(', ')})`, encodedLength);\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (this.coders.length !== value.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n\n    throw new FuelError(ErrorCode.ENCODE_ERROR, `Tuple encode unsupported in v1`);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid tuple data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = this.coders.map((coder) => {\n      let decoded;\n      [decoded, newOffset] = coder.decode(data, newOffset);\n\n      return decoded;\n    });\n\n    return [decodedValue as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport { MAX_BYTES, WORD_SIZE } from '../../constants';\nimport { chunkByLength } from '../../utilities';\nimport type { TypesOfCoder } from '../abstract-coder';\nimport { Coder } from '../abstract-coder';\nimport { U64Coder } from '../v0/u64';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport class VecCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n\n  constructor(coder: TCoder) {\n    super('struct', `struct Vec`, coder.encodedLength + WORD_SIZE);\n    this.coder = coder;\n  }\n\n  encode(_value: InputValueOf<TCoder>): Uint8Array {\n    throw new FuelError(ErrorCode.ENCODE_ERROR, `Vec encode unsupported in v1`);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    if (data.length < this.encodedLength || data.length > MAX_BYTES) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new U64Coder().decode(lengthBytes, 0)[0]).toNumber();\n    const dataLength = length * this.coder.encodedLength;\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + dataLength);\n\n    if (dataBytes.length !== dataLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec byte data size.`);\n    }\n\n    return [\n      chunkByLength(dataBytes, this.coder.encodedLength).map(\n        (chunk) => this.coder.decode(chunk, 0)[0]\n      ),\n      offsetAndLength + dataLength,\n    ];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport { arrayRegEx, enumRegEx, genericRegEx, stringRegEx, structRegEx } from './constants';\nimport type { JsonAbi, JsonAbiArgument } from './json-abi';\nimport { findOrThrow } from './utilities';\n\nexport class ResolvedAbiType {\n  readonly abi: JsonAbi;\n  name: string;\n  readonly type: string;\n  readonly originalTypeArguments: readonly JsonAbiArgument[] | null;\n  readonly components: readonly ResolvedAbiType[] | null;\n\n  constructor(abi: JsonAbi, argument: JsonAbiArgument) {\n    this.abi = abi;\n    const type = findOrThrow(\n      abi.types,\n      (t) => t.typeId === argument.type,\n      () => {\n        throw new FuelError(\n          ErrorCode.TYPE_NOT_FOUND,\n          `Type does not exist in the provided abi: ${JSON.stringify({\n            argument,\n            abi: this.abi,\n          })}`\n        );\n      }\n    );\n\n    this.name = argument.name;\n\n    this.type = type.type;\n    this.originalTypeArguments = argument.typeArguments;\n    this.components = ResolvedAbiType.getResolvedGenericComponents(\n      abi,\n      argument,\n      type.components,\n      type.typeParameters ?? ResolvedAbiType.getImplicitGenericTypeParameters(abi, type.components)\n    );\n  }\n\n  private static getResolvedGenericComponents(\n    abi: JsonAbi,\n    arg: JsonAbiArgument,\n    components: readonly JsonAbiArgument[] | null,\n    typeParameters: readonly number[] | null\n  ) {\n    if (components === null) {\n      return null;\n    }\n    if (typeParameters === null || typeParameters.length === 0) {\n      return components.map((c) => new ResolvedAbiType(abi, c));\n    }\n\n    const typeParametersAndArgsMap = typeParameters.reduce(\n      (obj, typeParameter, typeParameterIndex) => {\n        const o: Record<number, JsonAbiArgument> = { ...obj };\n        o[typeParameter] = structuredClone(\n          arg.typeArguments?.[typeParameterIndex]\n        ) as JsonAbiArgument;\n        return o;\n      },\n      {} as Record<number, JsonAbiArgument>\n    );\n\n    const resolvedComponents = this.resolveGenericArgTypes(\n      abi,\n      components,\n      typeParametersAndArgsMap\n    );\n\n    return resolvedComponents.map((c) => new ResolvedAbiType(abi, c));\n  }\n\n  private static resolveGenericArgTypes(\n    abi: JsonAbi,\n    args: readonly JsonAbiArgument[],\n    typeParametersAndArgsMap: Record<number, JsonAbiArgument>\n  ): readonly JsonAbiArgument[] {\n    return args.map((arg) => {\n      if (typeParametersAndArgsMap[arg.type] !== undefined) {\n        return {\n          ...typeParametersAndArgsMap[arg.type],\n          name: arg.name,\n        };\n      }\n\n      if (arg.typeArguments) {\n        return {\n          ...structuredClone(arg),\n          typeArguments: this.resolveGenericArgTypes(\n            abi,\n            arg.typeArguments,\n            typeParametersAndArgsMap\n          ),\n        };\n      }\n\n      const argType = findOrThrow(abi.types, (t) => t.typeId === arg.type);\n      const implicitTypeParameters = this.getImplicitGenericTypeParameters(abi, argType.components);\n\n      if (implicitTypeParameters && implicitTypeParameters.length > 0) {\n        return {\n          ...structuredClone(arg),\n          typeArguments: implicitTypeParameters.map((itp) => typeParametersAndArgsMap[itp]),\n        };\n      }\n\n      return arg;\n    });\n  }\n\n  private static getImplicitGenericTypeParameters(\n    abi: JsonAbi,\n    args: readonly JsonAbiArgument[] | null,\n    implicitGenericParametersParam?: number[]\n  ) {\n    if (!Array.isArray(args)) {\n      return null;\n    }\n\n    const implicitGenericParameters: number[] = implicitGenericParametersParam ?? [];\n\n    args.forEach((a) => {\n      const argType = findOrThrow(abi.types, (t) => t.typeId === a.type);\n\n      if (genericRegEx.test(argType.type)) {\n        implicitGenericParameters.push(argType.typeId);\n        return;\n      }\n\n      if (!Array.isArray(a.typeArguments)) {\n        return;\n      }\n      this.getImplicitGenericTypeParameters(abi, a.typeArguments, implicitGenericParameters);\n    });\n\n    return implicitGenericParameters.length > 0 ? implicitGenericParameters : null;\n  }\n\n  getSignature(): string {\n    const prefix = this.getArgSignaturePrefix();\n    const content = this.getArgSignatureContent();\n\n    return `${prefix}${content}`;\n  }\n\n  private getArgSignaturePrefix(): string {\n    const structMatch = structRegEx.test(this.type);\n    if (structMatch) {\n      return 's';\n    }\n\n    const arrayMatch = arrayRegEx.test(this.type);\n    if (arrayMatch) {\n      return 'a';\n    }\n\n    const enumMatch = enumRegEx.test(this.type);\n    if (enumMatch) {\n      return 'e';\n    }\n\n    return '';\n  }\n\n  private getArgSignatureContent(): string {\n    if (this.type === 'raw untyped ptr') {\n      return 'rawptr';\n    }\n\n    if (this.type === 'raw untyped slice') {\n      return 'rawslice';\n    }\n\n    const strMatch = stringRegEx.exec(this.type)?.groups;\n    if (strMatch) {\n      return `str[${strMatch.length}]`;\n    }\n\n    if (this.components === null) {\n      return this.type;\n    }\n\n    const arrayMatch = arrayRegEx.exec(this.type)?.groups;\n\n    if (arrayMatch) {\n      return `[${this.components[0].getSignature()};${arrayMatch.length}]`;\n    }\n\n    const typeArgumentsSignature =\n      this.originalTypeArguments !== null\n        ? `<${this.originalTypeArguments\n            .map((a) => new ResolvedAbiType(this.abi, a).getSignature())\n            .join(',')}>`\n        : '';\n\n    const componentsSignature = `(${this.components.map((c) => c.getSignature()).join(',')})`;\n\n    return `${typeArgumentsSignature}${componentsSignature}`;\n  }\n}\n","import { bufferFromString } from '@fuel-ts/crypto';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport type { BytesLike } from 'ethers';\nimport { sha256, getBytesCopy } from 'ethers';\n\nimport { AbiCoder } from './abi-coder';\nimport type { DecodedValue, InputValue } from './coders/abstract-coder';\nimport { ByteCoder } from './coders/v0/byte';\nimport { TupleCoder } from './coders/v0/tuple';\nimport { VecCoder } from './coders/v0/vec';\nimport { OPTION_CODER_TYPE } from './constants';\nimport type {\n  JsonAbi,\n  JsonAbiArgument,\n  JsonAbiFunction,\n  JsonAbiFunctionAttribute,\n} from './json-abi';\nimport { ResolvedAbiType } from './resolved-abi-type';\nimport type { Uint8ArrayWithDynamicData } from './utilities';\nimport { isPointerType, unpackDynamicData, findOrThrow, isHeapType } from './utilities';\n\nexport class FunctionFragment<\n  TAbi extends JsonAbi = JsonAbi,\n  FnName extends TAbi['functions'][number]['name'] = string,\n> {\n  readonly signature: string;\n  readonly selector: string;\n  readonly name: string;\n  readonly jsonFn: JsonAbiFunction;\n  readonly attributes: readonly JsonAbiFunctionAttribute[];\n  readonly isInputDataPointer: boolean;\n  readonly outputMetadata: {\n    isHeapType: boolean;\n    encodedLength: number;\n  };\n\n  private readonly jsonAbi: JsonAbi;\n\n  constructor(jsonAbi: JsonAbi, name: FnName) {\n    this.jsonAbi = jsonAbi;\n    this.jsonFn = findOrThrow(this.jsonAbi.functions, (f) => f.name === name);\n    this.name = name;\n    this.signature = FunctionFragment.getSignature(this.jsonAbi, this.jsonFn);\n    this.selector = FunctionFragment.getFunctionSelector(this.signature);\n    this.isInputDataPointer = this.#isInputDataPointer();\n    this.outputMetadata = {\n      isHeapType: this.#isOutputDataHeap(),\n      encodedLength: this.#getOutputEncodedLength(),\n    };\n\n    this.attributes = this.jsonFn.attributes ?? [];\n  }\n\n  private static getSignature(abi: JsonAbi, fn: JsonAbiFunction): string {\n    const inputsSignatures = fn.inputs.map((input) =>\n      new ResolvedAbiType(abi, input).getSignature()\n    );\n    return `${fn.name}(${inputsSignatures.join(',')})`;\n  }\n\n  private static getFunctionSelector(functionSignature: string) {\n    const hashedFunctionSignature = sha256(bufferFromString(functionSignature, 'utf-8'));\n    // get first 4 bytes of signature + 0x prefix. then left-pad it to 8 bytes using toHex(8)\n    return bn(hashedFunctionSignature.slice(0, 10)).toHex(8);\n  }\n\n  #isInputDataPointer(): boolean {\n    const inputTypes = this.jsonFn.inputs.map((i) =>\n      this.jsonAbi.types.find((t) => t.typeId === i.type)\n    );\n\n    return this.jsonFn.inputs.length > 1 || isPointerType(inputTypes[0]?.type || '');\n  }\n\n  #isOutputDataHeap(): boolean {\n    const outputType = findOrThrow(this.jsonAbi.types, (t) => t.typeId === this.jsonFn.output.type);\n\n    return isHeapType(outputType?.type || '');\n  }\n\n  #getOutputEncodedLength(): number {\n    try {\n      const heapCoder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output);\n      if (heapCoder instanceof VecCoder) {\n        return heapCoder.coder.encodedLength;\n      }\n      if (heapCoder instanceof ByteCoder) {\n        return ByteCoder.memorySize;\n      }\n\n      return heapCoder.encodedLength;\n    } catch (e) {\n      return 0;\n    }\n  }\n\n  encodeArguments(values: InputValue[], offset = 0): Uint8Array {\n    FunctionFragment.verifyArgsAndInputsAlign(values, this.jsonFn.inputs, this.jsonAbi);\n\n    const shallowCopyValues = values.slice();\n\n    const nonEmptyInputs = this.jsonFn.inputs.filter(\n      (x) => findOrThrow(this.jsonAbi.types, (t) => t.typeId === x.type).type !== '()'\n    );\n\n    if (Array.isArray(values) && nonEmptyInputs.length !== values.length) {\n      shallowCopyValues.length = this.jsonFn.inputs.length;\n      shallowCopyValues.fill(undefined as unknown as InputValue, values.length);\n    }\n\n    const coders = nonEmptyInputs.map((t) =>\n      AbiCoder.getCoder(this.jsonAbi, t, {\n        isRightPadded: nonEmptyInputs.length > 1,\n      })\n    );\n\n    const coder = new TupleCoder(coders);\n    const results: Uint8ArrayWithDynamicData = coder.encode(shallowCopyValues);\n\n    return unpackDynamicData(results, offset, results.byteLength);\n  }\n\n  private static verifyArgsAndInputsAlign(\n    args: InputValue[],\n    inputs: readonly JsonAbiArgument[],\n    abi: JsonAbi\n  ) {\n    if (args.length === inputs.length) {\n      return;\n    }\n\n    const inputTypes = inputs.map((i) => findOrThrow(abi.types, (t) => t.typeId === i.type));\n    const optionalInputs = inputTypes.filter(\n      (x) => x.type === OPTION_CODER_TYPE || x.type === '()'\n    );\n    if (optionalInputs.length === inputTypes.length) {\n      return;\n    }\n    if (inputTypes.length - optionalInputs.length === args.length) {\n      return;\n    }\n\n    const errorMsg = `Mismatch between provided arguments and expected ABI inputs. Provided ${\n      args.length\n    } arguments, but expected ${inputs.length - optionalInputs.length} (excluding ${\n      optionalInputs.length\n    } optional inputs).`;\n\n    throw new FuelError(ErrorCode.ABI_TYPES_AND_VALUES_MISMATCH, errorMsg);\n  }\n\n  decodeArguments(data: BytesLike) {\n    const bytes = getBytesCopy(data);\n    const nonEmptyInputs = this.jsonFn.inputs.filter(\n      (x) => findOrThrow(this.jsonAbi.types, (t) => t.typeId === x.type).type !== '()'\n    );\n\n    if (nonEmptyInputs.length === 0) {\n      // The VM is current return 0x0000000000000000, but we should treat it as undefined / void\n      if (bytes.length === 0) {\n        return undefined;\n      }\n\n      throw new FuelError(\n        ErrorCode.DECODE_ERROR,\n        `Types/values length mismatch during decode. ${JSON.stringify({\n          count: {\n            types: this.jsonFn.inputs.length,\n            nonEmptyInputs: nonEmptyInputs.length,\n            values: bytes.length,\n          },\n          value: {\n            args: this.jsonFn.inputs,\n            nonEmptyInputs,\n            values: bytes,\n          },\n        })}`\n      );\n    }\n\n    const result = nonEmptyInputs.reduce(\n      (obj: { decoded: unknown[]; offset: number }, input) => {\n        const coder = AbiCoder.getCoder(this.jsonAbi, input);\n        const [decodedValue, decodedValueByteSize] = coder.decode(bytes, obj.offset);\n\n        return {\n          decoded: [...obj.decoded, decodedValue],\n          offset: obj.offset + decodedValueByteSize,\n        };\n      },\n      { decoded: [], offset: 0 }\n    );\n\n    return result.decoded;\n  }\n\n  decodeOutput(data: BytesLike): [DecodedValue | undefined, number] {\n    const outputAbiType = findOrThrow(\n      this.jsonAbi.types,\n      (t) => t.typeId === this.jsonFn.output.type\n    );\n    if (outputAbiType.type === '()') {\n      return [undefined, 0];\n    }\n\n    const bytes = getBytesCopy(data);\n    const coder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output);\n\n    return coder.decode(bytes, 0) as [DecodedValue | undefined, number];\n  }\n}\n"],"mappings":"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","names":["import_errors","import_errors","import_errors","import_math","import_ethers","import_errors","import_math","import_ethers","import_errors","import_math","import_errors","import_math","import_utils","import_errors","import_math","import_errors","import_utils","import_ethers","import_errors","import_errors","import_errors","import_errors","import_math","import_errors","import_ethers","import_errors","import_errors","import_math","import_utils","import_errors","import_errors","import_math","import_utils","import_ethers","_getPaddedData","getPaddedData_fn","import_errors","import_math","BooleanCoder","import_errors","import_math","ByteCoder","import_errors","import_math","isFullyNativeEnum","EnumCoder","import_errors","import_math","NumberCoder","import_errors","import_math","RawSliceCoder","NumberCoder","import_errors","import_math","import_ethers","StdStringCoder","import_errors","import_ethers","StringCoder","import_errors","StructCoder","import_errors","TupleCoder","import_errors","import_math","VecCoder","import_errors","NumberCoder","RawSliceCoder","BooleanCoder","ByteCoder","StdStringCoder","StringCoder","VecCoder","StructCoder","EnumCoder","TupleCoder","import_errors","import_math","import_ethers"]}